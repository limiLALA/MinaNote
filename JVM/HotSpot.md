# 版本
# 概述
jvm的一种具体实现

# 内存划分
## 线程私有
### pc 程序计数器
### 虚拟机栈
> ### 虚拟机栈有可能发生两种exception
一种是典型的stackoverflow error，栈溢出
第二种是如果栈空间可以动态申请，而申请不到的时候，抛出OOM error
> ### 虚拟机栈基于栈帧运行
> 调用一个方法就会把那个方法封装为栈帧压入
执行完就弹出。
因此递归次数过多就StackOverflow error
此外虚拟机栈还有局部变量表和操作数栈
局部变量表与操作数栈进行交互
代码对操作数栈的栈顶元素起作用


### 本地方法栈
>结构基本与虚拟机栈一样，不过针对的是native方法的执行。


## 线程共享
### 方法区
> ### 1.8 以前使用永久代 permanent 实现
> ### 1.8 的版本方法区用 metaspace实现
直接使用操作系统的内存空间

### 堆
> ### 对象分配的地方
>> ### 年轻代 young
>>> ### minor GC 的主要位置
一般分为 eden survivor_from survivor_to
一般比例为 8:1:1
>> ### 老年代 tenured
>>> ### fullGc的主要位置

### 常量池
> ### 1.7 以前放在永久代
> ### 1.7开始 放在堆

# 创建对象策略
## 首先尝试 eden
> ### 如果对象过大
那么直接尝试在 tenured 分配对象
>> ### 如果 tenured 没有足够内存
那么触发 full Gc
>>> ### 如果 fullGC后仍然没有足够内存
那么触发 OOM error
> ### 如果对象不会太大
那么尝试在 eden分配
>> ### 如果eden已经满了
那么触发 minor GC

# 一些疑问
## 为什么废弃1.7的永久区
> ### 永久区没有GC，经常 OOM
> ### 为了与其他虚拟机进行整合
JRockit就没有 永久代
