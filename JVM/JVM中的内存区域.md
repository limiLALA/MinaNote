### 方法区（非堆区）
&emsp;&emsp;以字节码形式存放加载进来的类。其中存放了类变量。
>字节码执行引擎：用于执行方法区中的字节码指令。

### 程序计数器
&emsp;&emsp;存放当前字节码执行引擎执行的指令的地址。每个线程都拥有一个PC。

### java虚拟机栈
&emsp;&emsp;线程创建时会同时创建一个属于这个线程的虚拟机栈。
>栈帧：当执行到一个方法时，就会在虚拟机栈中为这个方法开辟一个栈帧，当这个方法执行完毕时，就销毁对应的栈帧。栈帧中包括了操作数栈、局部变量表、出口地址等部分。  
>>注意线程中如果有一个实例化的类的对象，则在局部变量表中存放的只是这个对象的引用，对象实际存放的位置在堆区。

### java堆区
&emsp;&emsp;存放代码中创建的类的对象，对象实例中会包含一些数据，如对象变量（类中定义的非静态变量）。  
>对象的内存占用：
* 对象本身的一些信息，比如对象头，64位系统中对象头占16字节。
* 实例数据，即对象中的变量（非类变量）。

### 本地方法栈
&emsp;&emsp;执行本地操作系统中的native方法时会在当前线程的本地方法栈中创建“栈帧”，与在虚拟机栈中创建栈帧类。native本地方法不是用java写的，大多用C语言写的。

### 总结
&emsp;&emsp;JVM是一个进程，进程创建时会分配一块内存空间，其中又被分为了多个不同的内存区域。  
&emsp;&emsp;刚开始有方法区（即非堆区），用于存放类加载进来后的字节码指令，还有一个字节码执行引擎。  
&emsp;&emsp;在引擎开始执行字节码指令之前，会创建一个线程，同时为这个线程分配一个程序计数器、虚拟机栈、本地方法栈。  
&emsp;&emsp;字节码引擎开始执行指令后，如果执行到某个指令是要执行另一个方法，就要在虚拟机栈中创建一个栈帧；如果执行的是本地方法，就在本地方法栈中创建栈帧。  
&emsp;&emsp;如果执行的指令是实例化一个类的对象，就在堆区分配内存空间给这个对象，将这个对象的地址压入线程的对应栈帧的操作数栈中，然后弹出放在局部变量表中。
