## 套接字Socket
连接应用层与传输层的一条管道，Socket可以作插口/插槽讲，客户端和服务端都有一个插口Socket，用于通信。

## 基于TCP/UDP的Socket编程
Socket是端到端的通信，意识不到中间经过了多少局域网、路由器。

### 建立Socket时要设置的参数
网络层：使用IPv4地址用AF_INET，IPv6地址用AF_INET6；给定IP地址。
传输层：指定TCP用参数SOCK_STREAM（数据流），UDP用参数SOCK_DGRAM（数据报）；给定端口号。

### 基于TCP协议的Socket程序函数调用过程
1. 服务端调用 ***bind*** 方法将 **监听Socket**(serv_sock) 与IP、端口绑定，这个套接字用于监听对应的网卡和端口，接收客户端的连接请求。

2. 服务端调用 ***listen*** 方法，使服务端进入监听状态，此时客户端可以开始发起连接。

3. 服务端调用 ***accept*** 方法，拿出一个已经完成的连接进行处理，如果没有完成的连接，就继续等待。
> 内核为每个服务端的serv_sock维护2个队列。一个队列放置处于**established**状态的连接，此时三次握手已经完毕，成功建立了连接；另一个队列放置处于**syn-rcvd**状态的连接，这时三次握手尚未完成，还没有完全建立连接。

4. 客户端调用 ***connect*** 方法，在参数中指定要连接的IP和端口，开始发起三次握手。
> 此时内核会给客户端分配一个临时端口，这个端口对客户端不可见，只有内核才知道这个客户端对应的端口号。

5. 握手成功，accept方法将返回一个 **已连接Socket**(clnt_sock) 给服务端，用于传输数据。
> 内核会为每个clnt_sock维护2个队列，分别是**发送队列**和**接收队列**。

6. 双方通过 ***read/write*** 函数，对clnt_sock读写数据，就像往一个文件流里写东西一样。

7. 断开连接：服务端调用两次close函数，关闭serv_sock和clnt_sock；客户端调用close函数关闭sock。

>每个进程有一个task_struct，其中存放了指向文件描述符数组fds的指针，这个数组列出了这个进程打开的所有文件的文件描述符，此处的文件描述符是一个整数，是真正的文件数组file list的下标，而file list中存放的才是inode的地址。  
Socket也有inode，只是不像一般文件的inode存在磁盘中，而是放在内存里。这个inode指向了内核中的Socket结构。  
这个Socket结构中存放了2个队列，分别是发送队列和接收队列，队列中保存的是一个缓存sk_buff，这个缓存中存放的是字节流。

#### TCP四次握手断开连接
* 客户端：我发完了数据，我要断开连接了。
* 服务端：哦，你要断开连接，那你等我准备一下。  
过了片刻...
* 服务端：我准备好了，可以断开连接了。
* 客户端：好的。

上面就是TCP四次握手的类比过程，具体过程如下：
1. 客户端发起断开连接请求，然后进入FIN-WAIT1
2. 服务端收到FIN请求后，返回ACK包，进入CLOSE-WAIT，此期间服务端做的工作就是把没接收完的数据都接收完并发送给对应的应用，此时TCP连接进入半关闭状态，此期间只允许服务端发送消息，客户端不能发送
3. 服务端准备好后，发送FIN请求，进入LAST-ACK，等待客户端的ACK
4. 客户端收到FIN请求后，返回对应的ACK，然后进入TIME-WAIT
5. 服务端收到ACK包，正式进入CLOSED

###### TIME-WAIT的说明
TIME-WAIT一般时长是2MSL，意味着客户端发出确认断开连接后还要再等待2MSL才能进入CLOSED。  
MSL是报文最大生存时间，客户端发出的ACK如果经过了1MSL还没有被服务端接收到，服务端就会重发FIN包，如果又过了1MSL客户端没有收到重发的FIN，说明服务端已经收到了ACK，此时客户端就可以放心的关闭连接。

>参考资料：
[TCP四次握手断开连接（图解）](http://c.biancheng.net/cpp/html/3043.html)

#### 基于UDP协议的Socket程序函数调用过程
###### 服务端
1. 生成套接字
2. 设置服务器IP地址和侦听端口
3. 绑定IP与端口
4. 调用recvfrom，进入阻塞状态，直至客户端发送消息给自己，则获取到客户端的地址信息
5. 调用sendto，发送消息给客户端
6. 反复执行3和4
7. 调用close，关闭套接字
###### 客户端
1. 生成套接字
2. 设置目标服务器IP地址与目标端口
3. 获取用户输入，放入缓冲区buffer，调用sendto，发送给服务端
4. 调用recvfrom，接收服务端的信息
5. 反复执行3和4
6. 调用close，关闭套接字

>参考资料：
* [Linux C Socket UDP编程介绍及实例](https://blog.csdn.net/lell3538/article/details/53335472?tdsourcetag=s_pcqq_aiomsg)
* [基于UDP的服务器端和客户端](http://c.biancheng.net/cpp/html/3052.html?tdsourcetag=s_pcqq_aiomsg)

### 服务器如何接更多项目
服务端**最大并发 TCP 连接数**远不能达到理论上限。首先主要是**文件描述符限制**，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是**内存**，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。

##### 方式一：将项目外包给其他公司（多进程方式）
复制父进程的所有资源，太过浪费。
##### 方式二：将项目转包给独立的项目组（多线程方式）
线程属于轻量级，但是有C10K 问题，线程太多，开销太大。
##### 方式三：一个项目组支撑多个项目（IO 多路复用，一个线程维护多个 Socket）
轮询，影响了一个项目组能够支撑的最大的项目数量。
使用 select，能够同时盯的项目数量由 FD_SETSIZE 限制。
##### 方式四：一个项目组支撑多个项目（IO 多路复用，从“派人盯着”到“有事通知”）
epoll 被称为解决 C10K 问题的利器。
