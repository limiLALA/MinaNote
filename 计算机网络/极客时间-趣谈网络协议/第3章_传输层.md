# 传输层
>整体结构（下层到上层）：**物理层-数据链路层-网络层-传输层-应用层**  
>>网络中的包可以有下层没上层，但是不能有上层没下层。

* 网络层中封装的是目的IP地址，即只负责将包传送到目的机器上，是点到点的传输。  
* 传输层中封装的是目的端口号，当包已经送达目的机器后，内核根据端口号来判断这个包应该交给哪个用户程序来处理，这是端到端的传输。

>各层封装名称
* 数据链路层：MAC帧
* 网络层：IP包
* 传输层：UDP数据报 / TCP报文段

# 一、UDP
&emsp;&emsp;用户数据报协议 UDP（User Datagram Protocol），面向无连接，里面封装的是可交付的用户数据报。
>&emsp;&emsp;所谓可交付，是目的主机上有进程在监听这个数据报中的目的端口号，内核在解析完MAC头和IP头后，可以根据传输层的UDP头或TCP头获取端口号，然后将这个包交付给在监听这个端口的用户程序。  
&emsp;&emsp;不可交付即没有任何进程在监听这个端口，此时包就会被丢弃，目的主机将向源主机发送终点不可达差错报文。

## UDP首部格式
![](UDP首部格式.png)
&emsp;&emsp;UDP首部共8个字节，包含源端口、目的端口、长度（即UDP首部长度与数据长度之和）、检验和。12字节的伪首部是为了计算检验而临时添加的。
>UDP一般与应用层结合起来使用。

# 二、TCP
&emsp;&emsp;传输控制协议 TCP（Transmission Control Protocol），面向连接。主要关注5个问题：顺序问题、丢包问题、连接维护、流量控制、拥塞控制。
## TCP首部格式
![](TCP首部格式.png)
TCP首部共20字节固定部分+可选部分。重要字段解释如下：  
**序号**：TCP会按序给每个**字节流**编号，保证按序发送。假设当前发出去的报文中序号为300，整个报文长度为250，则下一个报文的序号应为550。  
**确认号**：客服端/服务端希望接收的下一个TCP报文的序号。  
**数据偏移**：TCP首部的长度。  
**同步 SYN**：在连接建立时用来同步序号。连接请求报文和响应报文中SYN=1。    
**确认 ACK**：确认号字段是否有效的标志位。规定在连接建立后的ACK均为1。第一条报文（连接请求报文）中ACK=0,响应报文中的ACK=1，之后的报文中ACK均为1。  
**终止 FIN**：连接释放的标志位，当FIN为1时，表示此报文段的发送方已经发送完毕，要求释放连接。  

## TCP三次握手
![](TCP的三次握手.png)
第一次：客户端A发送连接请求报文给服务端B。
>序号=x，确认号无效，SYN=1,ACK=0,FIN=0

第二次：服务端B收到连接请求报文后，同意连接，回复连接确认报文给客户端A。
>序号=y，确认号=x+1，SYN=1,ACK=1,FIN=0

第三次：客户端A收到确认报文后，再次向服务端B发送确认连接报文。B收到A的确认连接报文后才知道A已经收到了自己的确认报文，于是正式建立连接。
>序号=x+1，确认号=y+1，SYN=1,ACK=1,FIN=0

#### 第三次握手的目的
>防止**失效的连接请求**使服务器错误打开连接。  
* 什么时候会出现失效的连接请求？
>>&emsp;当客户端发送的连接请求在网络中滞留时间过长导致超时，此时客户端会重新发送连接请求，此时第一个滞留连接请求已经到达服务器，于是服务器返回对应第一次连接请求的确认报文。  
&emsp;但是客户端已经放弃了第一次连接请求，当它检测到这个返回来的确认报文中的确认号不等于第二次连接请求报文中的序号+报文长度时，就会丢弃这个报文，不进行第三次握手，然后继续等待第二次连接请求的回复。  
&emsp;服务器B没有收到客户端A对于第一次连接确认报文的响应，就不会建立连接。  
&emsp;如果去掉第三次握手，那服务器最终会建立2个连接。

## TCP四次挥手
![](TCP的四次挥手.png)
#### 第一次
&emsp;客户端A向服务端B发送连接释放请求（FIN包）。然后进入**FIN-WAIT1**状态。
>序号=u，确认号无效，SYN=1,ACK=0,FIN=1

#### 第二次
&emsp;服务端B向客户端A发送释放确认报文，表示已经收到了连接释放的请求。发送完立马进入**CLOSE-WAIT**状态。
>此时TCP处于**半关闭状态**，即只有被动关闭的一方（服务端B）可以发送数据给主动关闭的一方（客户端A），反之不行。  

&emsp;客户端A接收到确认报文后，进入**FIN-WAIT2**状态继续等待。
>序号=v，确认号=u+1，SYN=1,ACK=1,FIN=1

#### 第三次
&emsp;数据接收完毕后，服务端B不再需要和客户端A保持连接，于是向客户端A发送连接释放报文（FIN包），然后进入**LAST-ACK**状态。
>序号=w，确认号=u+1，SYN=1,ACK=1,FIN=1

#### 第四次
&emsp;客户端A收到服务端B发送的连接释放报文后，向B发送确认报文，表示我收到了连接释放请求，你可以释放连接了。此时A进入**TIME-WAIT**状态，等待2 MSL（最大报文存活时间）后释放连接。   
&emsp;服务端B收到确认报文后，释放连接。

#### 四次挥手的原因
##### CLOSE-WAIT
>在收到客户端A的连接释放请求后就进入**CLOSE-WAIT**状态的目的是<u>为了让服务器B发送还未传送完的数据</u>  

##### TIME-WAIT  
>第四次挥手时，客户端A为什么要等待2 MSL再释放连接？
* 当客户端A发出的确认报文在一定时间内没有成功送达服务端B时，服务端B会重新发送连接释放请求报文。所以当A发送了确认报文后不能立马释放连接，只有在 2 MSL 内都没有再收到B的连接释放请求时才能放心的释放连接。
* 为了让本次连接持续时间内产生的所有报文都从网络消失，防止在下一次连接中出现旧的连接请求报文。

## TCP可靠传输
**超时重传**：TCP采用超时重传来实现可靠传输，即发出TCP报文后，如果没有在超时时间内收到TCP确认报文，就重传这个报文。  
**往返时间RTT**：发送-接收-确认，即从发出报文到对方接收报文到自己收到确认报文的时间。  
**加权平均往返时间RTTs**：RTTs=(1-a) * (RTTs) + a \* (RTT)   
**超时时间RTO**：略大于RTTs，RTO=RTTs + 4 * RTTd   
**偏差的加权平均值RTTd**

## TCP滑动窗口
### 通告窗口
>接收方维护的滑动窗口。用来告知发送方一次性最多连续发送多少字节。  
与接收方分配给接收缓存的大小有关。

### 拥塞窗口
>cwnd，发送方维护的滑动窗口。是发送方对网络拥塞状况的估计。

## TCP流量控制
>控制发送方的发送速率，保证接收方来得及接收。  
接收方向发送方发送的报文中的窗口字段可以控制发送方的窗口大小，从而控制发送方的发送速率。

## TCP拥塞控制
##### 分组丢失
>当网络拥塞时，分组（报文）会丢失，此时发送方会继续重传，使得网络更加拥塞。

>拥塞控制就是根据网络拥塞情况自动调整拥塞窗口大小，从而降低整个网络的拥塞程度。

>拥塞控制的四种算法：慢开始、拥塞避免、快重传、快恢复


### 慢开始与拥塞避免
>两种不同的控制发送速率的算法
#### 慢开始
>初始拥塞窗口大小为1，即一次只能发送一个分组。之后每次发送前都会将拥塞窗口增大到上一次的两倍，呈指数级增长，当拥塞窗口大小达到ssthresh时，转为拥塞避免算法。
>###### ssthresh
>>slow start threshold，慢开始门限。达到这个阈值时，拥塞窗口的大小停止慢开始式的指数级增长。

#### 拥塞避免
>初始拥塞窗口大小为ssthresh，之后线性增长，即每次收到ACK后就增长1/cwnd，如果收到了所有的ACK，相当于cwnd++。

### 快重传与快恢复
>在接收方，要求每次接收到报文段，都应该对接收到的最后一个有序报文段进行确认。比如接收到M1、M2，然后接收到M4，此时应该发送对M2的确认。

当发送方连续收到3个对同一个报文段的确认后，就说明下一个报文段已经在网络中丢失，于是**快重传**这个报文段。  

由于只丢失了一个报文段，故不是网络拥塞，接下来进行**快恢复**，即令ssthresh=cwnd/2，cwnd=ssthresh。注意到这里之后就直接进入**拥塞避免**状态了。

### 慢开始与快恢复的区别
这个快慢是针对cwnd而言，而不是发送速率。慢开始的慢是指初始cwnd=1，而快恢复的初始cwnd=ssthresh。

# 三、UDP与TCP的区别
用户数据报协议UDP是面向无连接的，尽最大可能交付，不保证送达，无拥塞控制，面向报文，传输过程简单、高效。支持一对一、一对多、多对一、多对多通信。

传输控制协议TCP是面向连接的，可靠交付，保证送达目的地，有流量控制、拥塞控制，面向字节流（将应用层传下来的报文看成字节流，将其组织成多个大小不等的数据块），传输过程安全、有序。仅支持一对一通信。
