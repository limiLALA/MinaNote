# 概述
> ### 垃圾回收机制
垃圾回收分为两个阶段
垃圾标记，垃圾清理

# 垃圾标记
* ## 引用记数法
>为每一个对象加一个引用计数器
用于统计该对象被引用的次数，次数为0说明可以标记为垃圾
需要繁琐地对计数器这个数据结构进行更改
而且会遇到循环引用的问题

* ## GC Root 可达性分析
> 使用一组可以确定为存活的对象的集合作为GC Root，然后从这堆对象出发寻找被他们引用的对象，也可以被认为是存活的对象并也加入到该gc root集合中。
可以作为 GC root 的对象有以下几种
已经加载的类的static 引用的对象
虚拟机栈局部变量表 中 引用的对
本地方法栈局部变量表 中 引用的对象
> ### 可达性分析可能遇到两个问题
>> ### 多标记
忘了清空引用，导致垃圾被标记为存活
从而造成内存泄漏
>> ### 少标记
漏标记了仍然需要被使用的对象



# 垃圾清理
## Stop the World
> 传统的垃圾清理进行的时候，要暂停除了GC线程以外的工作线程，直到完成垃圾回收
STW 是依赖安全点 safepoint 来实现的
安全点的意义在于，此时虚拟机的堆不会发生变化。
比如在执行native方法时，不会影响到虚拟机栈和堆内存。因此这段本地代码的执行中就可以作为安全点。


## 垃圾清理的几种算法
* ### 复制
> ### 复制的前提是有两个区域
在年轻代比较多使用。
具体的实现方式就是将一个区域的标记对象全部顺序复制到另一个区域


* ### 直接清理
> ### 将没有标记的对象的内存空间直接标为可用。
维护一张可用内存的表，指向这些内存块，注明大小。
显然这会造成内存碎片。

* ### 整理（压缩）
> ### 将标记的对象按顺序挪到前排，然后其它内存区域标为可用。
