>锁是用来实现数据库资源的并发访问规则的一种重要数据结构。

# 全局锁
**全局锁**：对整个数据库实例加锁。

### Flush Tables With Read Lock(FTWRL)
对数据库加全局读锁，使整个数据库处于只读状态。执行此命令之后，其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

### single-transaction
mysqldump是官方自带的逻辑备份工具，对于全部使用InnoDB等支持事务的引擎的库，使用参数single-transaction，即可生成可重复读隔离级别的一致性视图，保证备份过程中数据的一致性，避免出现幻读问题，同时又不妨碍其他线程对数据库进行写操作，对应用更友好。

但前提是库中所有表都使用支持事务的引擎，比如InnoDB。

MyISAM不支持事务，故只能使用全局锁FTWRL。

### 全局锁的应用场景
用于全库逻辑备份过程中，即将数据库每个表都select出来存成文本。

### set global readonly=true
该语句也可让数据库处于只读状态，但是相比于FTWRL，有以下2点缺陷：
1. 异常处理机制上的差异：客户端意外断开连接时，FTWRL会自动释放锁；但是readonly不会改变，系统将长时间处于不可写状态，这将极大地影响其他线程对数据库的操作，风险较大。
2. 影响面的差异：在某些系统中，readonly会用于其他业务逻辑，比如判断一个库是主库还是备库。如果修改global变量，影响面更大，因此不建议使用。

>业务的更新包括
1. 增删改数据（DML）：insert、delete、update
2. 加字段等修改表结构的操作（DDL）：alter

# 表级锁
## 表锁 lock tables
表锁的语法如下：
```sql
lock tables t1 read, t2 write;
...
unlock tables;
```
表锁会将整个表都锁住，这将限制其他线程的读写，同时也会限制本线程接下的操作对象。  
以执行上述语句为例（执行unlock tables之前）：
1. 其他线程无法对加了表读锁的表t1进行写操作，对加了写锁的t2进行读写操作。
2. 拿到锁的线程只能对t1进行读，t2进行读写，不能对t1进行写操作，也不能对除t1、t2以外的表进行操作。

>表锁一般用于MyISAM这种不支持行锁的引擎。   
对于InnoDB引擎，一般使用begin/commit来替换lock tables/unlock tables。

## 元数据锁 MDL(metadata lock)
在MySQL 5.5版本中被引入，当要对表进行操作时，系统会默认加上MDL锁。当要对表进行增删改查(DML)操作时，加MDL读锁；当要对表结构进行变更(DDL)时，加MDL写锁。

* 读锁之间不互斥
* 读锁与写锁、写锁之间互斥

#### MDL锁的不安全性
>**当语句开始执行时，系统会默认加上MDL锁，直至事务提交后锁才会被释放**。在执行表结构变更操作时，很有可能导致锁住线上查询和更新。

当对一个表进行select操作时，会加上读锁，如果在读锁释放之前另一个线程来进行DML操作，就会被阻塞，此后再有第三个线程来进行select操作时就会被第二个申请写锁的线程阻塞。此时此表将完全不可读写。

如果此表的查询语句频繁，而且客户端有重试机制，超时后会再生成新的session请求，这个库的线程将很快爆满。

##### 解决方案：如何安全地给小表加字段
* DDL NOWAIT：对于**长事务**，在MySQL的information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者 ***kill*** 掉这个长事务。
* DDL WAIT n：对于请求频繁但是数据量不大的**热点表**，可在alter table语句中加入***等待时间***，如果在等待时间内拿不到MDL写锁，就先取消掉，以免阻塞后面的线程。之后开发人员或DBA再使用重试命令重复此过程。

>MariaDB和AliSQL这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。
```sql
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ...
```
