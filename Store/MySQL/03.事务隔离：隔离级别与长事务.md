## 事务
事务：保证一组数据库操作要么全部成功，要么全部失败。

事务在引擎层实现，但不是所有的引擎都支持事务，比如MySQL原生的MyISAM就不支持事务。这也是MyISAM被InnoBD取代的原因之一。

ACID：Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性。事务的4个特性。

-------------------------------------------------
## 隔离级别
多事务并发执行的问题：脏读、不可重复读、幻读。

#### SQL标准的事务隔离级别
* **读未提交**：一个事务尚未提交时，其做的修改就能被其他事务看到
* **读提交**：一个事务提交后，其中做的修改才能被其他事务看到
* **可重复读**：在一次事务执行期间，看到的数据总是和刚启动时看到的数据一致。其做的修改也得提交后才能被其他（在其提交前未启动的）事务看到。
* **串行化**：对同一行记录，读会加“读锁”，写会加“写锁”。当出现读写冲突的时候，后一个事务必须等待前一个事务执行完成后才能继续执行。

#### 不同隔离级别的实现
* 读未提交：直接返回记录上的最新值，没有视图的概念。
* 读提交：在每条SQL语句开始执行的时候创建视图。
* 可重复读：在事务启动时创建一个视图，事务执行期间都使用这个视图。
* 串行化：没有试图，直接通过加锁来避免并行访问。

> Oracle 的默认隔离级别是读提交。

> **如何设置MySQL的隔离级别**
>> 将启动参数transaction-isolation的值设置成READ-COMMITTED。用show variables查看当前的值。
```sql
mysql> show variables like 'transaction_isolation';
```

> **什么时候使用可重复读**
>> 进行数据校对时，需要在事务执行期间始终读取同样的数据，此时就需要使用可重复读。事务启动时的视图可以看做是是静态的，不受其他事务影响。

#### 事务隔离的实现
* **回滚操作**：每条记录在更新时都会同时记录一条回滚操作，通过回滚操作就可以获取前一个状态的值。与隔离级别无关。回滚操作为了保证事务的一致性，在事务被中断时可以回退到事务开启的状态，从头来过。
* **数据库的多版本并发控制（MVCC）**：同一条记录在系统中可以存在多个版本。仅“读提交”与“可重复读”有MVCC的机制。

##### 回滚日志的删除
系统中没有比回滚日志更早的read-view时，就不再需要这个回滚日志。

##### 为什么不建议使用长事务
* 长事务意味着系统中存在很老的事务视图，它可能要使用的数据有很多。因此在事务提交之前，数据库中它可能要用的回滚记录都要保留，从而导致占用大量内存空间。
* 除了影响回滚段，长事务还会占用锁资源，也会拖垮整个库。

-------------------------------------------------
## 事务的启动方式
1. 显示启动事务：语句为begin/start transaction，配套的提交语句为commit。
2. 隐式启动事务：每执行一条SQL语句，会默认将其当做事务。当set autucommit=0，表示将此线程的自动提交关掉，该事务不会自动提交，直到你主动执行commit/rollback语句或者断开连接；当set autucommit=1，每执行完一条SQL语句都会自动commit。

> 无论autucommit是多少，只要使用了begin，都必须通过commit或commit work and chain进行提交。
commit表示仅仅提交事务，commit work and chain表示提交完当前事务后再开启下一个事务，省去了下次再输入begin。

> 建议set autucommit=1，通过显示语句启动事务。这样可以明确的知道每个语句是否处在事务之中。
