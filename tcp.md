# 概述

# 重要知识点
## 半开启
> 链接建立后一方事故断开，另外一方不知道

## 半连接
> 链接还没建立，一方处在syn_rece状态等待第三次握手，白白浪费资源

## 半关闭
> 一方发起fin并得到ack，不能再主动发消息，只能被动ack

## RTO
> 超时重传时间，根据RTT计算出来
相邻两次重传的时间间隔有所谓的 指数退避 的规律
1.5 3 6 12 24 48 64 64 64 ...

## RTT
> 数据包往返需要的时间

## 2MSL
> 四次挥手中主动发起的一方到达timed_wait状态之后需要等待的时间。
目的是为了接收到被动关闭的一方没有收到ack而重发的fin包

## 丢失分组
> 在两种情况下可以认为丢包，网络发生拥塞，并重传
>> ### 超时
>> ### 重复收到同一个ack的包
> 超过三次，则可以认为这个需要的包已经丢失。

## 流量控制
>### 拥塞避免算法
>> 假设网络拥塞导致丢包
相邻两次发送的分组数量采用线性增长。一开始可以只发一个
每个rtt往返时间内收到一个ack，cwnd 就 +1/cwnd，全收到了，就相当于cwnd++
>### 慢启动算法
>> 相邻两次发送的分组数量 **cwnd** 采用指数增长。一开始可以只发一个
1 2 4 ...
cwnd 初始为 1 每个rtt往返时间内收到一个ack，cwnd就+1
也就是发多少，下次就可以发当前的两倍

>对于给定的一个连接，有cwnd和slow start threshold两个变量，
tcp一次连续发送的报文数量，不能超过 Math.min(cwnd , 接收方通告窗口的length)

> ### 拥塞发生时
将当前的ssthreshold设置为
当前 **拥塞窗口大小的一半（Math.min(cwnd , 接收方通告窗口的length)/2）**
而且如果是超时引起的
那么将cwnd设置为1.这样子下一次发送就只能发送一个了。这就是慢启动。
> ### 收到新的ack时，又要开始加大窗口
此时根据采取的策略来判断增加的方式
>> ### cwnd 小于等于 ssthreshold
那么说明在慢启动，采取指数增长 cwnd， 这会持续到 拥塞发生前cwnd的一半
>> ### 否则
说明在拥塞避免，采取线性增长 cwnd 。


## 滑动窗口
> ## 通告窗口
>> 这是接收方维护的滑动窗口，用于告知发送方一次连续发送最多多少个报文
与接收方分配给接收缓存的大小有关。
> ## 拥塞窗口
>> 这是发送方维护的滑动窗口，是发送方对网络拥塞状况的估计。
