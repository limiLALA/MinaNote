###### 事务特性（ACID）->隔离级别->InnoDB默认隔离级别可重复读->MVCC->可重复读的问题->undo log

###### MySQL如何实现主备一致

###### 索引类型
唯一索引、普通索引。唯一索引是指用unique约束的列生成的索引。普通索引就没有这个unique约束，可以有重复值。
>说到这两个索引类型，我想再提一下change buffer写缓冲机制，这是只有普通索引才支持的一种机制，用于减少磁盘IO的耗费，将对非唯一索引的写操作暂存在change buffer中，等到下一次要对这个数据页进行读操作的时候再将其加载进buffer pool，然后将change buffer中记录的操作都更新到buffer pool中对应的这个数据页内，再将读结果返回给上层应用，这个数据页会在buffer pool中暂留一段时间，到合适的时机才会被刷回磁盘。  
->buffer pool是一种减少磁盘IO耗费的机制；以页的形式缓存数据，与OS一样，一个页对应机械磁盘的一个扇区（4K），这样可以提升效率；缓冲池常见的内存页管理算法是LRU，但是与OS使用的有点不同，InnoDB对其进行了优化。主要是为了解决两个问题：预读失效和  
->然后刚刚有提到数据页刷回磁盘的时机，这里要涉及到redo log+binlog容灾和两阶段提交的概念。redo log是InnoDB引擎才有的一种日志机制，其中记录的是在事务执行过程中对每个数据页所做的更改。binlog是Server层的日志系统，不区分引擎，它记录的只是已执行的SQL语句的原始逻辑。

###### redo log是怎么实现事务的
* redo buffer保存对数据库的修改，不用每次都刷新数据页，这是单独用binlog无法实现的
* redo log通过redo buffer来实现事务，在执行一个事务当中的多条语句的时候，InnoDB会将其对数据页的修改先写到redo buffer中，然后在commit的时候再写到buffer pool的真实数据页中。而对于不支持事务的MyISAM而言，每执行一条SQL语句都要直接对数据页进行修改。  
* redo log有2个作用，一是实现事务，二是将随机IO优化成顺序IO。
* redo log的两阶段提交保证的是与binlog的一致性。

###### InnoDB为什么要多加一个redo log？有binlog恢复数据不就够了吗？
binlog+redo log是实现事务的机制，只有binlog的MyISAM不支持事务，因此每次都会将数据页的更改持久化到磁盘，但是这个过程通常是随机IO，磁头要不断地大范围移动，寻找目标盘面和扇区，耗费较大。但是InnoDB的redo log在磁盘的位置都是连续的，其持久化过程是顺序IO，每次磁头仅需移动1个扇区，因此效率较高。binlog+redo log容灾机制就能够避免频繁将数据页刷回磁盘，同时由于有redo log和binlog的日志记录，即使意外宕机，数据没来得及刷回磁盘，但是因为redo log和binlog每次事务提交的时候都会持久化到磁盘，因此可以通过这两个日志记录来恢复数据。这就是InnoDB的WAL机制。另外，redo log的两阶段提交机制可以尽量避免与binlog不一致的情况。

###### 数据库设计表的三大范式
3+1范式
1. 第一范式：列不可再分
2. 第二范式：非主键必须依赖主键的全部列而不是部分列
3. 第三范式：主键A必须能够同时确定非主键B和非主键C，而不能是非主键B依赖主键A，C依赖B。非主键之间不能有依赖。
4. BC范式：候选键之间必须是完全依赖，而不能是部分依赖
>如仓库(仓库名，管理员，物品名，数量)  
候选键为（仓库名，物品名），（管理员，物品名）
其中存在仓库名对（管理员，物品名）的部分函数依赖，因此不符合BC范式。
改为：
仓库(仓库名，管理员)
库存(仓库名，物品名，数量)

[详解第一范式、第二范式、第三范式、BCNF范式](https://blog.csdn.net/Wenco1/article/details/88077279?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param)

###### 如何查询比较高效
查询时尽量利用索引覆盖，而且不要做会导致索引失效的查询操作
	1. 查询时尽量使用最佳左前缀，即查询条件如果有多条，其条件检查的顺序要按照索引树的搜索顺序排列；
	2. 尽量不要使用通配符在前的like模糊匹配；
	3. 字符串一定要加上引号，否则会退化成普通查询，进行全表遍历。
	4. 尽量不要在条件中使用聚集函数。

###### mysql中什么时候索引会失效？
1. 没有使用最佳左前缀，会导致索引部分失效
2. 使用了通配符在前的like模糊查询
3. 字符串没有加引号  
2和3都会导致全表遍历查询。

###### 如果一个sql查询太久了，有哪些可能的原因？
1. 连接故障：客户端与服务端之间的连接出现问题，发送的查询请求迟迟没有被服务端收到，或者服务端对应进程被阻塞/死锁。
2. 数据量大：sql查询基于非索引，因此需要遍历整张表来查询。同时数据量很大，遍历时间成线性增长，故需要查询很久。
3. 阻塞：表或者对应行被其他线程锁住，然后其他线程还迟迟没有commit，导致查询无法进行下去。
4. 使用了一致性读：在要执行sql查询的事务A开始后，事务B对要查询的记录执行了大量更新操作，产生了大量undo log，之后A才开始执行sql查询，于是需要读取这期间事务B写入的所有undo log，一步一步回到事务A开始执行的状态，从而得到一致性状态下的数据并返回。

###### 什么时候需要加索引？
* 经常要用到某字段进行查找时，需要基于该字段建立索引。我们平时经常用的一般是B+树实现的索引，如果索引值频繁被修改，就需要花费大量时间来维护这棵索引树，因此用一般是用读多写少的字段建立索引树。
* 索引可被分为唯一索引和普通索引。
* 如果需要确保业务更新操作过程中，表的某个索引不能出现重复值，就要使用唯一索引。否则，一般都建议使用普通索引+change buffer缓存机制。
* 在写多读少的场景下，需要进行频繁的磁盘IO操作，内存中的内存页要不断地更新，极大地影响效率和内存利用率。change buffer机制可以解决这种问题。
  * 如果一条SQL更新语句中要写的数据页不在内存中，会先将其更新操作存在内存中的change buffer中。待下一次对该数据页执行读操作时，再读出change buffer中关于该数据页的所有记录，对该数据页进行统一修改后再返回结果，这个过程叫做merge。
  * 这种机制可以极大地减少磁盘读的IO耗费，提高SQL语句的执行效率，同时节省内存占用。
* 在读多写少的场景下，很有可能出现每次在执行完一条写操作后立马就要对这个数据页执行读操作的情况，此时change buffer机制几乎无法再降低磁盘IO的次数，同时还要增加change buffer的维护成本，此时建议关闭change buffer的功能。
* 另外，如果我们经常要同时使用多个字段进行查询时，此时一般是需要建立一个复合索引，利用索引覆盖来加快索引的效率。

###### 聚集索引和非聚集索引
* 聚集索引将表数据都放在索引树上，每一个叶子节点都是一行数据，查找的依据一般都是主键。InnoDB的主键索引就是用聚簇索引实现的。
* 非聚簇索引的叶子节点只存放对应数据的地址，查找的依据可以是主键也可以是非主键索引字段。MyISAM就是使用非聚簇索引，真正的表数据都放在另一块内存空间中。
* 聚集索引的好处就是只需一次查询就能获得自己想要的列数据，而非聚集索引不一定能直接得到自己想要的列，所以可能需要二次查询，效率更低。但是非聚集索引更加轻量，适用于使用非主键索引进行查询的场景。

###### mysql的存储引擎有很多种，你有听过哪些？这些引擎有什么区别呢？
MySQL的存储引擎主要有MyISAM和InnoDB。
1. MyISAM不支持事务，InnoDb支持事务
2. MyISAM不支持行锁，InnoDB支持。
3. MyISAM可以没有主键，使用非聚簇索引；InnoDB必须要有主键，且使用聚簇索引来存储。
4. MyISAM会缓存表中行记录的总数，而InnoDB不会。因为MVCC机制有可能会在不同事务中生成不同的一致性视图，行总数在不同事务中可能是不同的，因此缓存行总数是无意义的。
>其他的区别在版本升级的过程中已经逐步同化了，比如MySQL 5.6之前只有MyISAM支持全文索引，在MySQL 5.6之后InnoDB也开始支持全文索引了。

###### mysql索引结构，特点，为什么使用这个
索引可以使用二叉搜索树、哈希表、B-树、B+树来实现。
1. MySQL采用B+树作为索引结构。
2. B+树的特点是树高比二叉搜索树低，这样查询数据时需要访问的层数可大大减少。
3. 原因：
* 与二叉搜索树相比，由于B+树是n叉搜索树，在同样数据量的情况下，B+树的高度不会过高。一般而言，索引的一个结点中的所有数据会存放在同一个扇区内，因此对索引每一层的访问都对应一次磁盘I/O，其时间主要分为2块，磁头移动寻找磁道的时间和磁盘转动寻找扇区的时间。故磁盘I/O的时间比内存I/O要长很多。因此减少磁盘访问次数就成为了提高数据库查询效率的关键点。
* 与哈希表相比，B+树支持范围查询，而哈希表不支持。
* 与B-树相比，B+树的非叶子节点不存储真实数据，而只会存放辅助查找的值，而B-树的真实数据分布在不同的层上，要进行范围遍历时会比较麻烦。B+树只要直接将所有叶子节点用双向链表进行组织，就可进行范围查询，非常方便。

>* 二叉平衡树：左右子树的最大深度之差不能超过1
* 红黑树：本质也是一棵二叉搜索树，规则是左右子树中更深的那棵子树的长度不能大于另一棵的两倍

###### 事务的特性，具体介绍
ACID
* 原子性：事务中的步骤要么不做，要么全做。
* 一致性：(选其一回答)
>抽象解释：事务执行的结果应该是使数据库从一种一致性状态变为另一种一致性状态。即哪怕事务被意外中断，其所做的修改不会更新到物理数据库上，即为一致性。
>举例解释：举个转账的例子，A转账给B一百块钱，要执行两步操作，首先从A的账户余额中扣除100，然后给B的账户余额增加100。这个转账操作必须是一个原子性的操作，否则，如果执行了第一步余额扣除操作，并同步到物理数据库上，此时事务突然被意外中断，第二步操作没有执行，那么A和B的总资产就变少了，此时就不是一致性状态了。

* 隔离性：并发执行多个事务，互不干扰。
* 持续性：事务一旦提交，其对数据库的改变就是永久性的。

###### 隔离级别，具体介绍
读未提交：所有事务可以看到其他未提交事务的执行结果。读未提交的数据，称为脏读。
读提交：所有事务只可以看到其他已提交事务的执行结果。
可重复读：在一次事务执行期间读到的数据都是一致的。
串行化：后来的事务必须等待前一个事务执行完毕才能开始执行。

###### 幻读
在不同时刻读到不同的数据的现象，就是幻读。
在MySQL中，通过将库的引擎设置为支持事务的引擎，如InnoDB，使用可重复读的隔离级别即可解决幻读问题。可重复读是通过在事务开始执行时生成一份一致性视图，即静态视图来实现的，在事务执行期间一直使用这份视图进行读操作，这样无论在什么时刻读都不会读到前后不一致的值。
