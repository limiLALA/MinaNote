###### 事务特性（ACID）->隔离级别->InnoDB默认隔离级别可重复读->MVCC->可重复读的问题->undo log

######MySQL如何实现主备一致

###### mysql中什么时候索引会失效？
1. 没有使用最佳左前缀，会导致索引部分失效
2. 使用了通配符在前的like模糊查询
3. 字符串没有加引号  
2和3都会导致全表遍历查询。

###### 如果一个sql查询太久了，有哪些可能的原因？
1. 连接故障：客户端与服务端之间的连接出现问题，发送的查询请求迟迟没有被服务端收到，或者服务端对应进程被阻塞/死锁。
2. 数据量大：sql查询基于非索引，因此需要遍历整张表来查询。同时数据量很大，遍历时间成线性增长，故需要查询很久。
3. 阻塞：表或者对应行被其他线程锁住，然后其他线程还迟迟没有commit，导致查询无法进行下去。
4. 使用了一致性读：在要执行sql查询的事务A开始后，事务B对要查询的记录执行了大量更新操作，产生了大量undo log，之后A才开始执行sql查询，于是需要读取这期间事务B写入的所有undo log，一步一步回到事务A开始执行的状态，从而得到一致性状态下的数据并返回。

###### 什么时候需要加索引？
* 经常要用到某字段进行查找时，需要基于该字段建立索引。我们平时经常用的一般是B+树实现的索引，如果索引值频繁被修改，就需要花费大量时间来维护这棵索引树，因此用一般是用读多写少的字段建立索引树。
* 索引可被分为唯一索引和普通索引。
* 如果需要确保业务更新操作过程中，表的某个索引不能出现重复值，就要使用唯一索引。否则，一般都建议使用普通索引+change buffer缓存机制。
* 在写多读少的场景下，需要进行频繁的磁盘IO操作，内存中的内存页要不断地更新，极大地影响效率和内存利用率。change buffer机制可以解决这种问题。
  * 如果一条SQL更新语句中要写的数据页不在内存中，会先将其更新操作存在内存中的change buffer中。待下一次对该数据页执行读操作时，再读出change buffer中关于该数据页的所有记录，对该数据页进行统一修改后再返回结果，这个过程叫做merge。
  * 这种机制可以极大地减少磁盘读的IO耗费，提高SQL语句的执行效率，同时节省内存占用。
* 在读多写少的场景下，很有可能出现每次在执行完一条写操作后立马就要对这个数据页执行读操作的情况，此时change buffer机制几乎无法再降低磁盘IO的次数，同时还要增加change buffer的维护成本，此时建议关闭change buffer的功能。
* 另外，如果我们经常要同时使用多个字段进行查询时，此时一般是需要建立一个复合索引，利用索引覆盖来加快索引的效率。

###### 聚集索引和非聚集索引
* 聚集索引将表数据都放在索引树上，每一个叶子节点都是一行数据，查找的依据一般都是主键。InnoDB的主键索引就是用聚簇索引实现的。
* 非聚簇索引的叶子节点只存放对应数据的地址，查找的依据可以是主键也可以是非主键索引字段。MyISAM就是使用非聚簇索引，真正的表数据都放在另一块内存空间中。
* 聚集索引的好处就是只需一次查询就能获得自己想要的列数据，而非聚集索引不一定能直接得到自己想要的列，所以可能需要二次查询，效率更低。但是非聚集索引更加轻量，适用于使用非主键索引进行查询的场景。

###### mysql的存储引擎有很多种，你有听过哪些？这些引擎有什么区别呢？
MySQL的存储引擎主要有MyISAM和InnoDB。
1. MyISAM不支持事务，InnoDb支持事务
2. MyISAM不支持行锁，InnoDB支持。
3. MyISAM可以没有主键，使用非聚簇索引；InnoDB必须要有主键，且使用聚簇索引来存储。
4. MyISAM会缓存表中行记录的总数，而InnoDB不会。因为MVCC机制有可能会在不同事务中生成不同的一致性视图，行总数在不同事务中可能是不同的，因此缓存行总数是无意义的。
>其他的区别在版本升级的过程中已经逐步同化了，比如MySQL 5.6之前只有MyISAM支持全文索引，在MySQL 5.6之后InnoDB也开始支持全文索引了。

###### mysql索引结构，特点，为什么使用这个
索引可以使用二叉搜索树、哈希表、B-树、B+树来实现。
1. MySQL采用B+树作为索引结构。
2. B+树的特点是树高比二叉搜索树低，这样查询数据时需要访问的层数可大大减少。
3. 原因：
* 与二叉搜索树相比，由于B+树是n叉搜索树，在同样数据量的情况下，B+树的高度不会过高。一般而言，索引的一个结点中的所有数据会存放在同一个扇区内，因此对索引每一层的访问都对应一次磁盘I/O，其时间主要分为2块，磁头移动寻找磁道的时间和磁盘转动寻找扇区的时间。故磁盘I/O的时间比内存I/O要长很多。因此减少磁盘访问次数就成为了提高数据库查询效率的关键点。
* 与哈希表相比，B+树支持范围查询，而哈希表不支持。
* 与B-树相比，B+树的非叶子节点不存储真实数据，而只会存放辅助查找的值，而B-树的真实数据分布在不同的层上，要进行范围遍历时会比较麻烦。B+树只要直接将所有叶子节点用双向链表进行组织，就可进行范围查询，非常方便。

>* 二叉平衡树：左右子树的最大深度之差不能超过1
* 红黑树：本质也是一棵二叉搜索树，规则是左右子树中更深的那棵子树的长度不能大于另一棵的两倍

###### 事务的特性，具体介绍
ACID
* 原子性：事务中的步骤要么不做，要么全做。
* 一致性：(选其一回答)
>抽象解释：事务执行的结果应该是使数据库从一种一致性状态变为另一种一致性状态。即哪怕事务被意外中断，其所做的修改不会更新到物理数据库上，即为一致性。
>举例解释：举个转账的例子，A转账给B一百块钱，要执行两步操作，首先从A的账户余额中扣除100，然后给B的账户余额增加100。这个转账操作必须是一个原子性的操作，否则，如果执行了第一步余额扣除操作，并同步到物理数据库上，此时事务突然被意外中断，第二步操作没有执行，那么A和B的总资产就变少了，此时就不是一致性状态了。

* 隔离性：并发执行多个事务，互不干扰。
* 持续性：事务一旦提交，其对数据库的改变就是永久性的。

###### 隔离级别，具体介绍
读未提交：所有事务可以看到其他未提交事务的执行结果。读未提交的数据，称为脏读。
读提交：所有事务只可以看到其他已提交事务的执行结果。
可重复读：在一次事务执行期间读到的数据都是一致的。
串行化：后来的事务必须等待前一个事务执行完毕才能开始执行。

###### 幻读
在不同时刻读到不同的数据的现象，就是幻读。
在MySQL中，通过将库的引擎设置为支持事务的引擎，如InnoDB，使用可重复读的隔离级别即可解决幻读问题。可重复读是通过在事务开始执行时生成一份一致性视图，即静态视图来实现的，在事务执行期间一直使用这份视图进行读操作，这样无论在什么时刻读都不会读到前后不一致的值。
