### Linux常用命令
```shell
free # 显示内存的使用情况
df # 查看磁盘占用情况
fdisk # 创建和维护分区表的程序
netstat # 显示网络状态，查看端口号的使用情况
ifconfig # 查看ip

touch # 创建或更新文件
mkdir # 创建目录
ln # 生成链接：硬链接、软链接(-s)。硬链接本质是inode，软链接本质是字符串（文件名）
cp # 拷贝文件/目录（-r）
find
chmod # 修改文件的权限
cat # 获取文件内容
tac # 反向获取文件内容
head # 查看头部的文件内容
tail # 显示尾部的文件内容
more # 一页一页地查看文件，空格翻页，enter多显示一行，q退出

man doc # 查看技术文档
echo # 回显
```
>cp相当于深拷贝，ln的硬链接相当于浅拷贝。
>硬链接本质上是生成一个inode指向同样的block，rm一个文件并不一定会释放对应的block，只有当所有指向这个block的inode（比如硬链接）都rm掉才会释放block，有点类似于JVM的GC。

###### 请简述cat和tail -f 的区别？
cat 显示的是文件夹的全部的数据
cat 静态查看文件夹数据
tail 显示尾部的文件夹数据
tail -n num 显示num条数据
tail -f 可动态监控数据的变化
###### Linux命令
查看进程运行状况（top实时、ps当前），查看网络端口（netstat）

###### 进程线程，一个进程中有10个线程，一个线程挂了，其他线程会挂吗？

###### 僵尸进程是什么
* 僵尸进程：当一个子进程运行完毕退出之后，其进程描述符依旧存在，只有父进程调用wait或waitpid才会释放子进程的描述符。如果父进程一直没有调用wait，子进程的进程号就无法被释放，成为僵尸进程。通过Linux shell命令ps可以看到僵尸进程的状态是Z，表示zombie。如果存在大量僵尸进程，将导致无法分配新的进程ID，即无法产生新进程。要消灭僵尸进程，只需将父进程杀死，让僵尸进程变为孤儿进程，被init收养后由init释放它占有的资源，从而结束掉僵尸进程。
* 孤儿进程：当父进程退出后，如果子进程还在执行或者已退出但是父进程没有wait它，那么这个子进程就会成为孤儿进程，被进程号为1的init进程收养。
* 守护进程：运行在后台的一种特殊进程。一般是随系统启动而产生的非交互式进程，除非强行终止，否则会一直运行到系统关机。
* 后台进程：

###### 你是怎么理解同步和异步的？
同步和异步是针对执行计划而言的。同步是严格按照执行计划的顺序执行下来，中途有可能为了同步其他线程而被阻塞或者轮询等待，即同步阻塞和同步非阻塞，比如父线程join一个子线程，父线程必须等到子线程返回才能继续执行，这叫同步。异步是指两个线程按照自己的执行计划进行，互不干扰，不会被阻塞，即异步非阻塞，比如父线程fork一个子线程后，可以继续执行接下来的执行计划，不知道也不用管子线程现在会执行到哪。

IO复用是异步还是同步？
IO复用是同步非阻塞的，由一个线程管理多个Socket通道，通过对Socket进行轮询来查看是否有IO通道发出IO请求，因此所有的IO请求都是同步进行，一次只能有一个Socket通道的IO请求被线程处理，其他通道的IO请求将在之后的轮询中被响应。
>IO复用->select、poll、epoll及三者的区别

###### 进程，线程的概念，他们之间的联系
* 进程是资源分配的基本单位，线程是处理器调度的基本单位。
* 一个进程中至少要有一个线程，一个进程中的多个线程共享进程的内存资源。
* 在Linux下没有这么明确的区分进程和线程，他们底层都是task_struct这样的一个结构，里面存放了mm_struct指针，表示页表指针，如果两个task_struct指向同一块mm_struck，说明这个一个进程下的两个线程，如果指向不同的mm_struct，说明是两个不同的进程。

###### 说一说进程调度有哪些方式
FCFS
最短作业优先调度
优先级调度
时间片轮转法
多级队列调度
多级反馈队列调度
>[进程调度](https://blog.csdn.net/zy010101/article/details/94469587s)

###### 说一说进程分配的问题

>[进程空间分配和堆栈大小](https://www.cnblogs.com/ladawn/p/8449399.html)
>[linux为什么需要内核栈，系统调用时直接使用用户栈不行吗？](https://www.zhihu.com/question/43699081/answer/124798606)

###### 进程如何同步
1. 信号量  
信号量本质就是一个整型变量，通过P和V操作来控制同步进程对临界区的访问。所谓临界区，就是一段对临界资源进行访问的代码。  
P、V操作都是原子性的操作，通过在运行期间屏蔽中断的方式来实现原子性。P将信号量s的值减一，V则将s加一。s的初始值表示能同时进入临界区的进程数目。如果s为非正数，P操作将其减一后会将调用P方法的进程加入阻塞队列。V则从阻塞队列中释放出一个进程。

2. 管程  
一般用于解决生产者消费者问题，相比信号量，省去了很多控制代码。管程的特点是只能有一个进程进入管程，其他进程都将被阻塞。管程通过使用2个条件变量full和empty的wait()和signal()操作来控制生产者和消费者的行为，避免向满缓冲区中插入东西或者消费空缓冲区。

3. 消息队列  
消息队列实际上是以一对原语来实现其功能，分别是send和receive，指明接收方和发送方以及要传递的消息。这样当一个进程执行完一段互斥代码后就可以调用send操作通知指定的被receive阻塞的进程去执行这段代码。

###### 进程间通信有哪些方法？
1. pipe：匿名管道，只能用于父进程与子进程之间的半双工通信。
2. FIFO：命名管道，可用于同一主机内任意两个进程间的通信，常用于客户-服务端应用程序中，FIFO作为汇聚点，在客户端进程和服务端进程之间传递数据。FIFO同步管道由读写进程创建，通过fd来访问同一个管道，从而实现进程间通信。这个管道随着读写进程的关闭而销毁。
3. 消息队列：不同于FIFO，消息队列进程独立于读写进程。
>~~（面试不用说）消息队列具有以下优点：
(1)消息队列独立于读写进程，由消息队列这个进程来负责统一管理，避免了FIFO的同步打开与关闭困难（如多进程打开文件时的重名问题，此时其他同步进程将出现报文件打开失败的错误）。
(2)读写进程仅需调用消息队列的API进行读写操作，不用自己提供同步方法，避免了FIFO的同步阻塞问题。
(3)消息队列中可以存放很多个打开的fd，读进程可以根据需要读取特定类型的消息。但是FIFO只能存放一个fd，读进程一股脑的读一堆进来，然后再将不需要的舍弃。~~
4. 信号量：就是一个计数器，用于同步多个进程对共享数据对象的访问。
5. 共享存储：多个进程共享同一块内存。具体来说是将这块内存映射到进程内的地址空间中，不用在内核空间中创建该存储块的fd，直接通过用户空间中的逻辑地址就能访问到同一个存储块的物理空间。这种方式需要使用信号量来同步对共享存储的访问，仅适用于要共享大块数据时。
6. Socket：用于跨主机或跨LAN的进程间通信。

>参考资料：
* [目前linux进程间通信的常用方法是什么(pipe？信号量？消息队列？)?](https://www.zhihu.com/question/23995948)
* [进程间通信-管道](https://zhuanlan.zhihu.com/p/106222551)
* [semaphore和mutex的区别？](https://www.zhihu.com/question/47704079)

###### 文件IO
每个文件file都有一个文件描述符fd，fd这个对象主要是用来指向文件所在地址。
当执行read操作时，会产生系统调用，内核会通过fd，从磁盘上文件的对应位置，以扇区(block)为单位，即4KB为单位加载进内核空间的页框（也是4KB）中，再从内核空间读取到用户空间的页框中，即完成一次读取（载入）操作。
当执行write操作时，也会产生一个系统调用，将指定的用户空间的n个内存页的内容写入内核空间的缓冲区，再写入磁盘的n个扇区。

###### 进程和线程，区别，哪个效率高，为什么
1. 定义：进程是资源分配的基本单位。线程是处理器调度的基本单位。
2. 区别：一个进程可拥有多个线程。每个进程都拥有自己独立的地址空间，而同一个进程内的线程共享该进程的地址空间。
3. 效率高低比较：
多进程并发与多线程并发没有绝对的效率高低，要视情况而定。  
如果是不同进程的线程切换，则与进程切换无异。  
如果是同一进程内的线程切换，则其成本和效率比进程切换效率更高。进程切换时，需要MMU进行缓存的刷新，即先清除前一个进程的缓存再加载后一个进程的缓存。但是进程内的线程切换无需进行如此大规模的MMU缓存刷新操作，开销较小。
>[Linux中进程和线程的开销基本一样啊，为什么还要多线程呢？](https://www.zhihu.com/question/19903801)

###### 死锁的条件，如何解决
死锁是多个并发进程因争夺系统资源而产生相互等待的状态。  
死锁有4个必要条件：
1. 互斥：不能有2个以上的进程同时占有同一份资源。
2. 占有且等待：一个进程在等待另一个进程释放其所需的资源。
3. 不可抢占：一个进程不可强行将另一个进程已经占有的资源抢过来。
4. 循环等待：存在一个进程链，每个进程所需的部分资源被后一个进程所占有。

解决方案  
1. 死锁预防：破坏4个必要条件之一。比如破坏“占有且等待”，就可以在进程开始运行前就一次性为其分配好所有需要的资源。
2. 死锁避免：在进程运行前进行判断，只允许不会产生死锁的进程申请资源。比如银行家算法，通过提前模拟一个进程的运行过程来判断是否会导致死锁。
