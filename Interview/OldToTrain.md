###### 如何查询比较高效
###### 类加载过程（Java），每一步做了什么
###### 三次握手的时候双方会交换什么数据？
###### 为什么TCP中的初始化序列号要是随机的？
###### 口述一下快排的思想
###### 流量控制（零窗口的含义、接受窗口的协商）
###### 聚集索引和非聚集索引
###### AtomicInteger，原理是什么，如何做到高效率的，有什么优化措施
CAS；本地方法，硬件级别的原子操作；LongAddr机制，将多线程竞争1个资源变成竞争n个资源。
###### 悲观锁和乐观锁
###### 垃圾回收机制GC，cms，G1，垃圾回收的算法
* CMS通过 **牺牲GC系统的吞吐量(单位时间执行GC的次数)** 来获得**最短回收停顿时间STW**，但是由于STW时间减少了，单位时间内响应的用户线程的请求增多了，所以整个系统的吞吐量反而增大了。
* 三色标记法：
1. 黑色：对象被标记，内部的引用也被标记完毕
2. 灰色：对象被标记，但是内部的引用没有被标记
3. 对象未被标记
* CMS/G1如何降低GC带来的系统响应延迟？
* CMS碎片整理；G1控制GC时间，计算Region回收效率，优先队列。
###### 数据库的隔离级别？底层怎么实现的可重复读？
###### TCP和UDP的区别
1. TCP可靠，UDP不可靠
2. TCP有序，UDP无序
3. TCP面向字节流，UCP面向报文
4. TCP面向连接，UDP面向无连接
5. TCP支持流量控制和拥塞控制，UDP不支持
6. TCP仅支持一对一通信，UDP支持一对一、一对多、多对多

###### TCP三次握手
1. 客户端发送SYN包，CLOSED->SYN-SEND
2. 服务端发送SYN+ACK包，LISTEN->SYN-RCVD
3. 客户端发送ACK包，SYN-SEND->ESTABLISHED
4. 服务端收到ACK，SYN-RCVD->ESTABLISHED
上述过程均由OS全权处理，不经过应用层
携带信息：初始序列号、端口号、滑动窗口大小、最大消息长度等
###### TCP四次挥手
1. 客户端发送FIN包，ESTABLISHED->FIN-WAIT1
2. 服务端返回ACK包，ESTABLISHED->CLOSE-WAIT；客户端收到ACK，FIN-WAIT1->FIN-WAIT2
3. 服务端发送FIN包，CLOSE-WAIT->LAST-ACK
4. 客户端返回ACK包，FIN-WAIT2->TIME-WAIT，2MSL后进入CLOSED
5. 服务端收到ACK，LAST-ACK->CLOSED
* CLOSE-WAIT在干嘛？此期间TCP连接处于半关闭状态，主动发起断开连接的一方（这里是客户端）只能收不能发，被动要求断开连接的一方（服务端）如果是数据接收方，会让应用进程尽快拿走接收缓存中的数据，如果是数据发送方，会将发送窗口中的剩余数据发送出去。准备工作做完后，就通知客户端自己可以断开连接了。
* TIME-WAIT为什么要等待2MSL？TCP有一个报文超时重传机制，一般设置的超时时间t低于MSL（最大报文存活时间），发出报文起计时，如果超过时间t还没有收到ACK，就会重发这个报文。如果客户端返回的ACK丢失，没有被服务端收到，那么在2MSL内客户端大概率会收到服务端重传的FIN报文，然后重新返回一个ACK，仍然继续等待2MSL再进入CLOSED状态。假设客户端没有等待2MSL而是直接关闭连接，一旦这个唯一的ACK丢失，不管服务端怎么重传FIN都得不到任何回应，但是又不敢把连接断开，于是这个端口就永远无法被释放，造成端口浪费。
###### TCP如何保证可靠性的
###### String，StringBuffer，StringBuilder区别
String对象一旦定义，其中的字符串就不可变，不可变就意味着线程安全。一般用作map的key，因为不可变，所以hashCode也是不变的，便于map的存储。同时也用作网络传输的数据格式，不易被他人恶意修改，保证网络安全。
StringBuffer是可变的，内部使用char[]数组来存储字符串，通过append、insert、setCharAt等API来修改字符串。同时是线程安全的，内部的方法都使用了synchronized修饰。适用于并发度较高的场景。
StringBuilder与StringBuffer类似，唯一的区别在于StringBuilder是线程不安全的，没有synchronized加锁。适用于并发度小的场景。
###### mysql的存储引擎有很多种，你有听过哪些？这些引擎有什么区别呢？
###### ip头tcp头udp头这些能不能介绍一下？
###### 进程间通信有哪些方法？
###### 浏览器输入完url按下回车开始到返回页面的过程

###### JVM内存分区
方法区（非堆）、程序计数器PC、虚拟机栈、堆区、本地方法栈
方法区用于存放加载进来的类信息以及所有的方法代码，在程序运行过程中PC会指向方法区中要执行的下一条指令。
每个线程都有一个虚拟机栈，当执行到某个方法时，会将该方法的栈帧入栈，栈帧中包含了操作数栈、局部变量表、出口地址等。局部变量表中的基本类型数据是私有的，但是对象引用指向的堆中的对象是共享的。
堆区一般比较大，是用于存放对象的，由于对象都有一定的存活时间，随时都会产生一些不再需要的垃圾对象，因此对应的就有一些GC垃圾回收机制。
本地方法栈是用于存放本地方法的，如果线程执行到一个native方法，就会将这个方法对应的栈帧入栈，与虚拟机栈类似，只不过面向的是本地方法。本地方法一般的C编写的程序。

###### 网络层协议
有IP和ICMP。IP协议是用于规范网络层的格式，确保有源IP地址和目的IP地址，声明数据报的长度，以及上层协议。如果使用了ICMP，那么IP头中的协议字段就是ICMP，但这并不意味着ICMP是传输层的协议，因为ICMP报文中并没有端口号字段，它只是一个网络层协议。
ICMP有两种应用，分别是ping和Traceroute。ping是用到的是ICMP查询报文，用于探测某个IP是否存在以及能否响应。Traceroute使用的是差错报文，它有2大作用：一是用来追踪一个数据报发送过程途径的所有路由器，这是通过设置特殊的TTL值来实现的，一开始TTL是1，之后依次是2,3,4...，从而获取到每一跳的IP地址。当TTL减为0时，最后一个收到这个报文的的路由器就会向源主机返回一个超时差错报文，这样就可以拿到该路由器的IP地址。第二个作用是确定这条路径的最小MTU（允许通过的最大报文长度），这需要设置不分片位，让路由器返回终点不可达差错报文。

###### 死锁的必要条件？如何解决死锁问题？
* 必要条件：
1. 互斥：一个资源不能同时被2个进程占有
2. 占有且等待：一个进程可以无限期地占有某个资源，而另一个线程再等待它释放资源
3. 不可抢占：一个进程不能强行抢占另一个进程已经占有的资源
4. 循环等待：存在一个环形进程链，每个进程所需资源都被后一个进程占有
* 解决方案：
1. 死锁预防：破坏上述4个必要条件之一，比如占有且等待，可以在进程运行之前就为其分配好所需的所有资源
2. 死锁避免：在进程运行前预判，只允许不会导致死锁的进程申请资源。比如银行家算法，通过提前模拟一个进程拿到资源后的运行过程来判断是否会发生死锁。
