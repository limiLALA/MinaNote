###### 有哪些办法可以解决线程安全问题
多线程编程的3个核心概念：原子性、可见性、顺序性
1. 同步锁：锁和同步(方法/代码块)  
通过锁来实现资源的排他性，保证目标代码段的原子性
```Java
public void testLock(){
    lock.lock();
    try{
      i++;
    } finally{
      lock.unlock();
    }
}
```
```Java
public void testLock(){
    synchronized(anyObject){
      i++;
    }
}
```
```Java
public synchronized void testLock(){
    i++;
}
```
2. 乐观锁：CAS（compare and swap）  
原子操作类AtomicInteger使用CPU级别的CAS指令，保证基础变量自增的原子性。相比需要操作系统参与的锁，开销更小。
3. volatile关键字  
不保证操作的**原子性**，只保证内存变量的**可见性**和代码执行的**顺序性**。
用volatile修饰的变量，线程将其加载到自己工作内存中进行修改就会立即写回主内存，同时使得其他线程缓存中的变量失效，其他线程要进行读的话必须从主内存中重新加载。  
适用场景：其他线程通过某个停止线程的状态标记来控制工作线程是否继续执行
```Java
boolean isRunning = true;
public void start(){
    new Thread(()->{
      while(isRunning){
        doSomeOperation();
      }
    })
}
public void stop(){
    isRunning = false;
}
```
在上面的实现方式下，即使其他线程通过stop()方法将isRunning置为false，循环也不一定会结束，可以通过volatile关键字修饰isRunning来保证while循环能否即使得到isRunning最新状态从而使循环及时停下。

>[Java进阶（二）当我们说线程安全时，到底在说什么](http://www.jasongj.com/java/thread_safe/)

###### Java的内存泄漏在哪些情况下会出现
1. 长生命周期的对象持有短生命周期对象的引用，尽管短生命周期对象不再被使用，但是由于长生命周期对象持有它的引用导致不能回收。
* 静态集合类：如HashMap、LinkedList。如果这些容器为静态，那么他们的生命周期与程序一致，则容器中的对象在程序结束之前都不会被释放，从而导致内存泄漏。
* 内部类持有外部类对象的引用，即使外部类对象不再被使用，但是由于内部类持有其引用，导致无法被释放。
* 用栈储存对象，在pop时如果没有将pop掉的对象的引用置为null，就会导致内存泄漏。
* 缓存泄漏，一旦把对象引用放入缓存中，就很容易忘记释放，可以使用WeakHashMap来解决。此种Map的特点是，除了自身有对key的(弱)引用外，此key没有其他(强)引用，那么在GC时就会释放这个key的值。
2. 各种连接(数据库、网络、IO连接)未释放
3. 变量不合理的作用域
4. 改变哈希值：当对象被存入HashSet后，其用于计算哈希值的参数不能被更改，一旦被更改，即使在contains方法中用该对象的引用作为参数去HashSet中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet中单独删除当前对象，导致内存泄漏。
> [java中内存泄露8种情况的总结](https://blog.csdn.net/weter_drop/article/details/89387564)

###### Java的引用类型有哪些？
* 强引用：我们平时使用的最多的就是强引用，直接用一个引用变量指向一个对象，比如Integer i = new Integer(0);
* 软引用：拥有软引用的对象一般不会被JVM回收，只有当堆的使用率临近阈值时，才会去回收软引用的对象。可以用SoftReference实例来保存Java对象的软引用。软引用主要用于实现类似缓存的功能，当内存空间足够的时候，可以直接通过软引用取值，无需从繁忙的真实来源查询数据。
* 弱引用：只要GC启动就会回收弱引用的对象，可以和引用队列配合使用，主要用于监控
* 虚引用：与没有引用几乎一样，必须和引用队列结合使用，用于检测对象是否从内存中删除
>[JAVA中的引用](https://www.cnblogs.com/czx1/p/10665327.html)

###### spring的工厂模式
* spring通过BeanFactory这个工厂来管理Bean。
* BeanFactory本身是一个接口，ApplicationContext是对这个接口的实现，它首先需要读取xml配置文件，在这个配置文件中声明了很多个Bean，这些Bean就是需要创建的对象，全部由BeanFactory管理。
* Bean从生命周期上可以划分为Singleton和Prototype。Singleton在spring开始运行的时候就会被创建，Prototype只有在调用getBean的时候才会被创建，并且每次调用都会创建新的对象。
* Bean从用途上可以划分为普通Bean和FactoryBean。如果是普通Bean，通过getBean返回的就是这个对象，如果是FactoryBean，返回的就不是这个FactoryBean对象了，而是工厂Bean代理创建的实例对象。
* 这里说到了BeanFactory和FactoryBean，名字看上去挺像的，但是这两者完全不是一个概念。BeanFactory是一个容器，用于管理xml配置文件下的所有Bean；而FactoryBean只是一个特殊的Bean，只是在getBean的时候返回的不是本身，而是代理创建的实例对象，它也是由BeanFactory管理的。

###### synchronized的升级机制
1. 首先要说下对象在内存中的存储。堆中的对象由对象头、实例数据、对齐填充3部分组成。  
2. 对象头又包含2部分，第1部分用于存储运行时对象的自身数据，叫做markword，包含了hashCode、偏向时间戳、GC分代年龄、锁标志位、偏向线程ID、指向栈中锁记录的指针、指向Monitor重量级锁的指针等信息。第2部分是指向类元数据的指针，虚拟机运行时通过这个指针来得知这个对象属于哪个类。  
3. synchronized的升级机制与对象头中的markword密切相关。markword在32/64位虚拟机中分别占用32/64位的空间，我以32位为例。这个32个bit可以分时表示5种不同的状态，用1bit的偏向锁标志位与2bit的锁状态位表示，010表示无锁，110表示偏向锁，000表示轻量锁，001表示重量锁，011表示GC。synchronized的升级机制涉及到的是前4个状态，从前到后逐层升级。
4. synchronized的具体升级过程
* 对象头的markword初始是无锁状态
* 第一个线程T1到达同步区，检查markword，发现是无锁状态，于是将其升级为偏向锁，同时用CAS将偏向线程ID变成自己的ID
* 第二个线程T2到达同步区，检查markword，发现是偏向锁，然后再检查偏向线程ID是否是自己的，发现不是，于是让JVM去检查T1的状态，
	* 如果T1没有在运行或者已经退出同步区，就将偏向锁降级为无锁，然后T2将偏向线程ID替换成自己的，同样也是用上一步的CAS操作。
	* 如果T1仍在运行且仍在同步区内，等待T1运行到安全点，再暂停T1。此时JVM将偏向锁升级为轻量锁。
* 升级轻量锁后，markword变为匿名状态，即32位全0，JVM在T1栈帧中生成一个锁记录，将匿名markword拷贝到该锁记录中，令markword中的指针指向T1的锁记录，最后唤醒T1线程。
* T2不停将当前对象头markword与匿名markword比较
	* T1没有退出同步区，T2将一直比较失败
	* T1退出同步区，释放了轻量锁，markword恢复匿名状态，此时T2比较成功，进入下一环节。
* JVM在T2栈帧中生成一个锁记录，拷贝匿名markword进去，并用与前面T1同样的CAS操作将当前对象头的markword的指针替换成T2的锁记录的首地址，假设此时T3也比较成功了，并且抢先一步替换成功，T2的CAS失败，于是JVM将轻量锁升级为重量锁。
* 升级为重量锁后，markword的最后两位为01，前30位指向对象实例数据中的Monitor对象，Monitor底层是使用OS的mutex lock对线程进行过阻塞，因此T2就被阻塞并放入对象的锁池中，等待被唤醒。

>[synchronized关键字详解及分析锁升级过程](https://blog.csdn.net/baidu_38083619/article/details/82527461)

###### 了解过ThreadLocal吗？原理是什么
ThreadLocal用于隔离线程，保证各个线程都拥有自己私有的变量副本，互不干扰。这些变量一般是和线程绑定的状态信息，如用户ID、事务ID等。  
每个Thread对象都拥有一个实例变量threadLocals，其中存放了属于这个线程的所有ThreadLocal变量，可以通过调用ThreadLocal对象的set、get方法访问到对应的value，initValue会返回线程本地变量初始值，remove将移除对应的ThreadLocal变量。  
事实上，ThreadLocal本身不存储值，真正起作用的是ThreadLocal的静态内部类ThreadLocalMap，上面提到的threadLocals其实就是ThreadLocalMap类型的实例，其中放了很多个Entry，即K-V键值对，ThreadLocal对象只是作为key，用于映射map中的value，这才是真正存储值的地方。  
总结来说，每个Thread对象中有一个ThreadLocalMap对象的引用，叫做threadLocals，threadLocals中放了很多K-V键值对，key是ThreadLocal对象的引用，value是专属于这个线程的本地变量，也是对象引用，可以是Integer，也可以是String等。不同的线程可以共用同一个ThreadLocal对象，即用相同的key，但是因为map是线程独有的，其映射的value一定不会是同一个对象引用，从而实现了多线程间变量的隔离问题。  
与多线程同步不同，多线程同步解决的是多线程操作同一个共享变量的问题，而ThreadLocal解决的是线程本地变量隔离的问题，保证一个线程只能操作自己的本地变量，不会干扰到其他线程的本地变量。  
但是ThreadLocal有一个内存泄漏的风险。从源码中可以看到Entry中key的引用是弱引用，这对GC回收是有利的，但是又因为value是强引用，因此就会出现key被GC变为null，而value仍保留着强引用的情况，此时value不再被使用，但却一直被Thread对象间接强引用着，导致其内存一直无法被释放，除非Thread对象被清理掉。为了解决这个问题，ThreadLocalMap中的setEntry和getEntry中有这样一个判断，如果刚好找到一个key==null的Entry，就会将对应的value置为null，当然我们也可以显式调用ThreadLocal的remove方法进行处理。

>[【死磕Java并发】—–深入分析ThreadLocal](http://cmsblogs.com/?p=2442)

###### JVM内存分区
方法区（非堆）、程序计数器PC、虚拟机栈、堆区、本地方法栈
方法区用于存放加载进来的类信息以及所有的方法代码，在程序运行过程中PC会指向方法区中要执行的下一条指令。
每个线程都有一个虚拟机栈，当执行到某个方法时，会将该方法的栈帧入栈，栈帧中包含了操作数栈、局部变量表、出口地址等。局部变量表中的基本类型数据是私有的，但是对象引用指向的堆中的对象是共享的。
堆区一般比较大，是用于存放对象的，由于对象都有一定的存活时间，随时都会产生一些不再需要的垃圾对象，因此对应的就有一些GC垃圾回收机制。
本地方法栈是用于存放本地方法的，如果线程执行到一个native方法，就会将这个方法对应的栈帧入栈，与虚拟机栈类似，只不过面向的是本地方法。本地方法一般是用C编写的程序。

###### Object类里面有哪些方法？解释一下几个重点方法
重要的方法有getClass/hashCode/equals/clone/notify和wait/finalize
* getClass是获取对应类的Class对象，通过这个对象可以获取类元数据和类信息的入口
* hashCode用于获取对象的哈希值，如果不重写，默认是用对象的基址来计算，意味着同一个类的2个不同对象的hashCode是不同的，这个hashCode会存在对象头中。
* equals是非本地方法，不重写的话默认是和传入的对象引用直接进行基址的比较，也可以重写自定义比较规则。
* clone用于克隆对象，在另一块堆内存中创建一个相同的对象，包括其中的变量引用等，都是直接复制相应的值，属于浅拷贝。
* notify和wait要配合使用，与对象的锁池和等待池有关，通常与synchronized一起使用。synchronized是一个关键字，用于修饰方法或者代码块，表示这段代码加了独占锁，同一时刻只能有一个线程拿到对象的Monitor并执行，其他想要拿锁的线程都将被阻塞并放在对象的锁池中，一般用于需要同步线程的场景下。在synchronized修饰的代码块中，可以通过调用对象的wait方法去阻塞已经进来的线程，wait会将对应线程加入对象的等待池，并释放Monitor锁，唤醒锁池中的下一个线程。notify是用于唤醒等待池中的第一个线程，然后再放入锁池中，再次进入阻塞，等待Monitor锁被释放。相应的还有一个notifyAll，与notify类似，唯一的区别在于notifyAll是唤醒等待池中的所有线程。
* finalize在Object中默认什么都不做，这个函数在对象要被GC回收的时候会自动触发，如果我们希望在回收这个对象之前做一些逻辑处理，就需要重写finalize方法。
>[从JDK源码角度看Object](http://cmsblogs.com/?p=5200&tdsourcetag=s_pcqq_aiomsg)

###### 子类和父类的实例变量和方法有什么区别
* 实例变量是归对象所有，每个对象都有自己单独的实例变量，子类和父类也是一样，子类只是继承了父类的属性，只要创建了新的子类对象，就会在堆中单独开辟出新的内存空间用于存放这些实例变量，与父类无关。父类的实例对象也会有自己独立的实例变量。
* 方法代码都存放在非堆中，子类继承父类，意味着子类可以调用父类的方法，具体调用过程由JVM去操作，对用户是透明的，因此我们感觉就是子类复制了父类的方法代码一样，实则不然，他们实际执行的都是同一块内存中的方法代码。
* 只有当子类重写了父类的方法或者添加的自己的方法时，才会在子类所在内存空间中增加新的方法代码。如果是动态方法，会去方法区中查询对应类的方法表，其中存放了所有动态方法的符号引用到直接引用的映射，包括所有父类的方法和自己独有的方法，其中重写的方法会映射到子类所在内存空间中的方法入口地址。这是实现运行时多态的基础。

###### java泛型
* Java的泛型类似于C++的模板template，用诸如<E>这样的形式表示。用在集合中是为了兼容所有的类型，同时也是为了统一集合中的引用数据类型。比如ArrayList，底层是用数组实现，数组中存放的都是某种数据类型的引用，具体是哪种数据类型需要在创建对象的时候才能确定，比如ArrayList<Integer> arr = new ArrayList<Integer>();就表明这个集合中的元素都必须是Integer的引用。
* 泛型可以是任意一个符号，比如MyClass<E>，E就是一个泛型，可以用E去定义泛型引用，也可以作为方法的参数类型和返回值类型。
* 泛型可以延伸出泛型方法、泛型类、泛型接口三大应用。泛型方法的参数必须有泛型，其返回值可以是泛型，在调用方法传参的时候才能确定泛型的具体类型。泛型类是指在定义类的时候声明泛型，比如ArrayList<E>等JDK集合类都是泛型类。泛型接口是在定义接口的时候声明泛型，实现类可以直接指定泛型的类型，也可以不指定，但是也要声明泛型。
* 泛型还有一个概念是泛型上限和泛型下限。List<? extends B>表示后面的<>只能传入B或B的子类，这叫泛型上限；List<? super B>表示后面的<>只能传入B或B的父类，这叫泛型下限。泛型上限只能用于获取某些对象的值，不能调用其中需要传递泛型参数的方法，比如add()。泛型下限则可以，但是传递的泛型只能是B/B的子类。
>[java泛型理解和深入](https://zhuanlan.zhihu.com/p/40925435)

###### 发生exception的时候是怎么进行try catch finally的？底层原理是怎么实现跳转的
在反编译字节码中可以看到有一个Exception Table字段，其中包含了exception的类型，from、to、target字段，如果从from到to的代码执行过程发生异常，就会跳转到target处处理异常。

###### 你有接触过设计模式吗？有听过哪些设计模式？单例模式是怎么实现的？
* 有单例、工厂、观察者等设计模式。
* 单例模式是指一个类只能有一个实例，并提供全局访问点。
* 单例模式是通过一个私有构造函数、一个私有静态变量、一个公有静态方法来实现的。私有构造函数是为了防止外界通过直接调用构造函数来创建实例对象，限制其只能通过调用公有静态方法返回唯一的私有静态变量，即单例。
* 单例模式有很多种实现方式：
1. 懒汉式-线程不安全  
不加锁，私有静态变量初始化为空。在公共静态方法中判断私有静态变量是否空，如果空，new一个新对象给它然后返回，如果不空，直接返回。  
很明显，在多线程并发的场景下，很有可能会有多个线程重复给私有静态变量赋新值，出现线程不安全的问题。
2. 饿汉式-线程安全  
不加锁，但是在类加载的时候就实例化，即初始化私有静态变量，之后调用公有静态方法时直接返回即可。
利用了类加载的线程安全机制，缺点是提前占用了内存资源，在有些时候是不必要的浪费。
3. 懒汉式-线程安全  
与<懒汉式-线程不安全>的区别在于，给公有静态方法加上了独占锁，用了synchronized修饰。  
虽然安全，但是可能会导致大量线程被阻塞在这个公有静态方法上，内核用户态切换频繁，导致效率下降。
4. 双重校验锁-线程安全  
在公有静态方法中的判空语句中再嵌套一个判空语句，并在第二个判空语句前加上独占锁。与<懒汉式-线程安全>相比，这种实现方式可以一定程度上降低线程阻塞概率，效率更高。
5. 静态内部类  
将私有静态变量定义及其实例化语句放在静态内部类中，只有当外部类调用内部类的这个变量时，内部类才会被加载进内存，在类加载的时候实例化语句才会执行。  
这也是利用了类加载的线程安全机制，与饿汉式不同的是，此方法只会在需要的时候才会加载类并实例化，节省内存资源，同时又实现了线程安全。
6. 枚举实现  
定义enum枚举类，其中定义一个枚举成员INSTANCE，默认为公有静态常量，并在类加载的时候被实例化，与饿汉式类似，只不过换了种定义方式。要使用该单例的时候直接用枚举类名.INSTANCE即可。
7. 乐观锁实现
在<懒汉式-线程不安全>的基础上，用CAS乐观锁的方式对公有静态变量进行赋值，保证所有竞争线程中只有一个能成功给该变量赋值，从而实现线程安全的单例。

###### 你有用过java的反射吗?java的反射可以拿来干什么？
* Java反射是通过调用Field/Method对象的API，来访问对象中的对应字段或方法。
* 这种反射通过调用Class对象的API实现的，而Class对象可以通过类名Object.class或者对象名object.getClass()获取。Class对象不是我们自己创建的，而是在.class加载进内存时由JVM虚拟机自动创建的，包含了一系列用于访问类元信息的API。比如class.getDeclaredField("字段名")可以获取A类中某个字段的Field，实则是该字段相对于类/对象首地址的偏移量。而class.getDeclaredMethod("方法名")可以获取Method对象。
* 如果该字段或者方法是私有或者保护成员，可以先调用Field/Method对象的setAccessible(true)方法设置访问权限，然后再通过Field/Method对象的get进行访问。如果一个对象的私有/保护字段没有set/get方法，而我们要去访问这些成员时，就要通过反射的方式进行读取/修改。
* Java的反射在一些框架中有所使用，比如spring的依赖注入。Spring用到的是IoC容器，即控制反转，就是将创建对象的控制权反转给spring，由spring去替我们去创建对象然后返回给我们使用，同时控制对象的生命周期，我们只需要配置xml文件声明我们需要的对象即可。此时就需要Spring来替我们进行对象中各个字段的注入。然后往往我们自己写的类，有时候会缺少一些get/set方法，这样Spring就无法替我们进行字段的注入，因此反射机制就显得尤为重要了。

###### 对String及其不可变性的理解
* String是被声明为final的，即不可以被继承。Java 8中使用char[]数组来储存数据，Java 9开始改用byte[]储存。
* String的不可变是指一旦给定了一个字符串对象，其中的字符串就不可修改，只能创建新的字符串对象。
* String不可变有4大好处：
  1. 缓存hash值：因为String的hash经常被使用，比如作为HashMap的key来使用，String不可变的话，hash值就仅需计算一次。
  2. String Pool的需要：如果一个String对象已经被创建过了，就能在String Pool中取得引用。只有String不可变，才可能使用String Pool。
  3. 网络安全：在进行信息通信时，参数往往都是以字符串的形式传递。如果字符串可变，很容易就会被篡改，导致信息不一致。
  4. 线程安全：String的不可变性本身就保证了线程安全，可以在多线程间安全地使用。
* String Pool的理解
  * String Pool用于存储字符串字面量，这些字面量在编译期间就确定。在Java 7之前String Pool放在运行时常量池中，属于永久代，但是由于永久代空间有限，在需要大量使用字符串的场景下会出现OOM的问题，因此从Java 7开始移到了堆中。
  * 执行如下语句时，如果String Pool中还没有这个字面量和指向该字面量的String对象，则会生成2个String对象。首先在String Pool中生成一个String对象sp，其value指向字面量"aaa"。然后在堆中生成一个String对象，sp作为参数传入拷贝构造函数。
  ```Java
  String s1 = new String("aaa");
  ```
  最终调用的构造函数如下：
  ```Java
  public String(String original) {
      this.value = original.value;
      this.hash = original.hash;
  }
  ```
  可以看到新对象并没有完全复制字符串，而是指向了同一个value引用。这叫做浅复制。
  * 还可以在运行过程中通过stringObj.intern()方法将字面量加入String Pool中，如果String Pool中查到已经有了这个指向这个字面量的String对象，就会直接返回这个String对象的引用。如果没有，在Java 1.6中会在String Pool中新建一个String对象指向这个字面量，然后返回这个新对象的引用。而在Java 1.7中会在String Pool中加入这个字面量与stringObj的引用，不会再新建实例对象。这种优化的目的主要是为了节省内存。
  >StringDemo及其说明如下
  ```Java
  //编译期间会确定"ab"和"cd"这两个字面量，运行时首先在String Pool中生成这2个字面量和对应的实例对象，然后在toString的时候在堆中生成实例对象ss1，value="abcd"也是在堆中生成，String Pool中不会生成"abcd"的字面量。
  String ss1 = new String("ab") + "cd";//<=> String ss1 = new StringBuilder("a").append("bc").toString();
  //Java 1.6：在String Pool中生成新的实例对象和字面量"abcd"，返回新对象的引用
  //Java 1.7：将堆中实例对象的引用连同字面量加入String Pool，返回ss1对象的引用
  String intern_ss1 = ss1.intern();
  //Java 1.6：false
  //java 1.7：true
  System.out.println(ss1 == intern_ss1);
  //在String Pool中查到了"abcd"字面量及其映射的引用
  //Java 1.6：返回String Pool中的对象的引用
  //Java 1.7：返回堆中ss1的引用
  String ss2 = "abcd";
  //Java 1.6：false
  //Java 1.7：true
  System.out.println(ss1 == ss2);
  //在堆中生成新的实例对象ss3
  String ss3 = new String("a")+"b";
  //由于第1行已经将"ab"加入常量池，因此String Pool中已经有了"ab"对应的实例对象，此时直接返回String Pool中的对象引用
  String intern_ss3 = ss3.intern();
  //均为false
  System.out.println(ss3 == intern_ss3);
  ```
  不用intern的情况(结果上Java 1.6与1.7一致)：
  ```Java
  String ss1 = new String("ab") + "cd";
  //在String Pool中加入字面量"abcd"，并生成新的实例对象指向该字面量，返回新对象的引用
  String ss2 = "abcd";
  //均为false
  System.out.println(ss1 == ss2);
  ```

###### 面向对象的特性
封装、继承、多态。
* 封装就不用多说了。
* 继承是一种类间关系，子类继承父类，意味着子类拥有父类的非私有成员，并且可以重写父类的成员函数。所有抽象类和无显式继承关系的类都默认继承实体类Object，因此可以用Object引用指向所有的对象。
* 多态分为编译时多态和运行时多态。这种多态是通过类对象的方法表实现的。编译后会将调用方法的代码转换成invoke助记符+方法标签的形式，而动态方法的具体入口地址要在运行时从类加载进来的方法表中查找得到（静态方法无需加入方法表，在运行时直接用相对类对象的偏移量替换）。
  * 编译时多态是指在编译期间就确定了要使用的方法是哪一个。比如同一个类中方法的重载，编译期间根据参数就能知道具体要调用哪个方法表中的哪一个方法，在字节码中表现为方法标签的差异，这是静态绑定。
  * 运行时多态是指必须在运行的时候才能知道具体要调用哪一个方法。比如多个子类继承同一个父类，用父类的引用去指向不同的子类对象，并调用重写的非静态方法时，在运行时才能知道要调用的是哪个子类重写的方法，在字节码上表现为方法标签相同，但是运行时会从局部变量表中拿到不同对象的引用，去不同的子类中查找相应的方法表，这叫做动态绑定。这种多态的特性可以使得程序更加简洁统一，在不同情况下要调用不同子类方法，用一个父类引用分时指向不同的子类对象即可，而不用刻意去创建子类的引用，更加灵活。但是有一个弊端就是父类引用不能访问子类独有的成员，因此出现这种需求时仍需要特殊处理。

###### 谈谈你对接口和抽象类的理解
* 抽象类和接口都是不能被实例化的。接口可以看做是抽象类的延伸。
* 抽象类中的成员方法可以实现也可以不实现。成员的访问权限可以是public、protected、private任意一种。抽象类可以被多个子类继承，但是一个子类不能继承多个父类。其继承关系具有严格的类层次要求。
* 接口中的成员都必须是public，字段均默认为static和final的。在Java 8之前，接口中的方法均不能有默认的方法实现。当其他类实现该接口后，必须要实现其中的所有方法，因此如果要对接口进行改动，增加成员方法的话，就要改动实现了该接口的所有类，维护成本较高。从Java 8开始，接口中的方法也可以有默认的方法实现（用default声明），这样就降低了修改接口的成本。接口可以被多个类实现，一个类可以实现多个接口，打破了类继承严格的类层次限制，灵活性更强，再加上Java 8对接口的改进，我们可以说接口优先于抽象类。
* 不过事无绝对，在不同场景下有不同的选择。
  * 3种情况下需要使用抽象类
    1. 相关的类之间需要共享代码时；
    2. 要能控制继承来的成员的访问权限，而不是全为public；
    3. 要继承成员变量是非static和非final的。
  * 2种情况下用接口
    1. 需要让不相关的类实现同样的方法。比如不同的类都可以实现Comparable中的compareTo方法；
    2. 需要多重继承来继承多个类中的方法时，不如直接实现多个接口，简化继承关系。
* 接口可以继承接口，比如List继承了Collection；抽象类可以实现接口；抽象类可以继承实体类，比如所有的抽象类都继承自Object类。

###### AtomicInteger，原理是什么，如何做到高效率的，有什么优化措施
* AtomicInteger是对int的封装，提供原子性的访问与更新操作，其原子性操作的实现是基于unsafe类的CAS。CAS，即compare and swap(比较和交换)，涉及3个操作数：要更新的内存值V，进行比较的值A，拟写入内存的值B。CAS会先将V与A进行比较，如果相等，就将B赋值给V，如果不等，则开始自旋，进行下一次CAS。
* Java中CAS的底层是调用了C++的本地方法，本地方法再调用CPU指令集，通过基于硬件的原子操作来实现CAS的原子性和高效性。
* AtomicInteger的LongAdder就是一个优化措施，通过分段来降低并发度，将多线程竞争1个资源变成了多线程竞争n个资源，比如使用cell[4]这样的数组。如果要获取数据，就将4个cell数据相加返回，如果要修改数据，就修改自己当前被分配到的cell资源。比如线程A分配到cell[0]，线程B分配到cell[1]。A执行getAndIncrement操作的过程就是将4个cell相加作为返回值，然后将cell[0]进行原子性的加一操作（即CAS）；B执行decrementAndGet操作的过程则是先将cell[1]进行原子性的减一操作（即CAS），然后将4个cell相加并返回。

###### 悲观锁和乐观锁
* 悲观锁假设最坏的情况，总认为自己去拿数据的时候别人会来修改。而乐观锁则是假设最好的情况，每次都不会有其他人来修改数据。
* 悲观锁的典型实现有synchronized和Reentranlock，通过加独占锁的方式使得其他要来修改数据的线程被阻塞。
  * synchronized是一种非公平机制的锁，每次释放锁时，所有锁池中的线程均可竞争锁，虽然不公平，但是保证了高吞吐量。
  * Reentranlock有公平和非公平两种机制，公平就是先到先得，后到排队，非公平就是每个新到的线程都会去尝试拿锁，拿不到了再乖乖排队等候，如果没轮到自己当队头，之后都不能竞争锁，这与synchronized的非公平不太一样。
* 乐观锁的典型实现有版本号机制和CAS算法。
  * 版本号机制会有一个version记录修改次数，每当要更新一个数据时，会同时取出数据和对应的版本号version，更新完数据要写回时，会先检查版本号是否和原来一致，如果一致就将版本号加一，然后同时将版本号和数据刷回去，如果不一致，此次提交就会被驳回。
  * CAS，即compare and swap（比较与交换），先比较后更新，涉及3个操作数：要更新的内存值V，进行比较的值A，拟写入的新值B。如果V==A，就将B赋给V，CAS成功；否则CAS失败。通常与自旋操作搭配使用，失败就取新值继续比较，直至CAS成功为止。
* 下面我讲讲synchronized与CAS的应用场景
  * synchronized一般用于线程冲突严重（资源竞争严重）的场景，如果这种场景下使用CAS的话，大概率会导致线程自旋，白白消耗CPU资源，而用synchronized加锁的话，会直接阻塞线程，避免CPU资源的浪费。
  * CAS一般用于线程冲突较轻（资源竞争较少）的场景，如果这种情况下使用synchronized的话，线程都不会被阻塞太久，此时的线程阻塞唤醒切换、用户态内核态的切换等操作反而会额外消耗CPU资源；而CAS基于硬件实现，不需要进入内核，无需切换线程，同时自旋概率较小，因此性能更高。
>参考资料：[面试必备之乐观锁与悲观锁](https://blog.csdn.net/qq_34337272/article/details/81072874)
[简述乐观锁和悲观锁](https://blog.csdn.net/qq_32600929/article/details/89089577)

###### 垃圾回收机制GC，cms，G1，垃圾回收的算法
常见的垃圾回收器有Serial和Serial Old，ParNew和CMS，以及G1回收器。  
* Serial和Serial Old都是单线程的回收器，前者针对新生代，后者针对老年代。现在Java后端基本不怎么用了。  
* ParNew是针对新生代的支持多线程并发的GC，使用复制算法对新生代垃圾进行回收，将堆内存中的新生代划分为一个Eden区和2个Survivor区，比例一般设置为8:1:1。在运行过程中总会预留一个空闲的Survivor区，举个例子，在某次回收时会将Eden区和S1的存活对象复制到S2区，然后清空Eden区和S1区，接下来只有Eden区和S2区存放对象，直至下一次回收，又将存活对象搬至S1区，清空Eden和S2区，如此往复。  
* CMS是针对老年代的支持多线程并发的垃圾回收器，回收过程要经过初始标记、并发标记、重新标记、并发清理4个步骤。初始标记会让系统线程停止工作，进入Stop the World状态，然后将GC Roots直接引用的对象标记为存活对象；并发标记让系统线程恢复运行，同时进行GC Roots跟踪，将所有GC Roots间接引用的对象都找出来并标记；重新标记又会进入Stop the World，将上一步并发标记过程中发生变化的对象标记出来，包括哪些对象变成垃圾对象，哪些对象是新产生的；并发清理阶段又会让系统线程恢复，然后并发地去清理之前标记出来的所有垃圾对象。由于清理完后，老年代内存空间中的存活对象一般都是东一个西一个，很零散，因此会造成大量内存碎片，JVM有个参数可以设置每几次Old GC进行一次碎片整理。
* G1垃圾回收器也是支持并发线程的，同时负责清理新生代和老年代。并且可以手动控制其垃圾清理对系统性能的影响。
G1将堆内存划分成许多个Region，一般JVM中最多有2048个Region。
G1不明确划分新生代和老年代，而是在运行过程当中进行动态分配和动态转移。
所谓动态分配，举个例子，由于新生代最多占60%的空间，一开始新生代只占2%，然后在不断运行过程中新生代的对象占用会不断增长，直至增长到60%就会触发对新生代的GC。
而动态转移是指，当新生代的某个Region被清空后，这个Region下一次可能就被分配给老年代了。
值得注意的是，在G1机制中，大对象不属于老年代，而是单独分配Region，有可能一个大对象会横跨多个Region。
另外G1的新生代的内存分配依旧是一个Eden区和2个Survivor区，其比例一般也是8:1:1，比如某时刻新生代占了1000个Region，那么其中Eden区占800个Region，Survivor区各占100个，新生代的GC也是使用复制算法，与ParNew类似。
除了新生代触发的垃圾回收，还有老年代触发的混合回收机制。当老年代内存占比超过45%时，就会触发Mixed GC，在这个过程中会同时对新生代、老年代和大对象进行回收。GC过程分为初始标记、并发标记、最终标记、混合回收4个步骤。前三步与CMS的类似，区别在于最后一步。混合回收过程中会计算每个Region中存活对象占比、执行垃圾回收的预期性能与效率，选取部分Region进行回收，保证清理时间不超过预先人为设定的时间。这样就保证了垃圾清理不会对系统性能造成太大的影响。实际上在G1中会记录每个Region的垃圾占用，并据此维护一个优先队列，而清理的具体过程就是从优先队列中弹出部分垃圾占用较高的Region进行回收，另外还有一个规则，如果垃圾占用低于20%就不会去回收这个Region。注意在Mixed GC中的回收也是使用复制算法，将所有Region中的垃圾对象都复制到空闲Region中，然后一次性清理掉原来的Region，这样就避免了内存碎片的问题。

###### String，StringBuffer，StringBuilder区别
* String对象中所包含的是一个不可变字符串序列，一但定义了一个String对象，其中的字符便不可修改。
* StringBuffer对象中操作的是一个可变字符序列的字符缓冲区，实际上就是一个char[]，可通过append、insert、setCharAt等方法来修改字符串，最终通过toString转换成想要的字符串。
* StringBuilder与StringBuffer类似，唯一的不同点在于StringBuffer是线程安全的，而StringBuilder是不安全的。StringBuffer通过对每个方法都加上synchronized关键字的方式进行加锁，从而实现线程安全。但是在并发度较小的情况下建议使用StringBuilder，性能更高。

###### 谈谈你对线程池的理解
线程池的思想有点类似于IoC，也是控制反转。将手动创建线程变成了由机器自动创建线程，根据系统情况调整线程数目，降低了内存的消耗，并减少了创建和销毁线程的次数，每个工作线程可被重复利用。

###### 什么叫做JIT compiling，与传统的编译技术有何不同。
JIT，Just-In-Time，是即时的意思，即时编译器也叫做热点编译器，是一种动态编译器。

不同于C/C++的静态编译，JIT compiler是运行时编译（Runtime Compilation），一般应用于Java虚拟机中。Java解释器会将热点代码（即频繁被执行的字节码）交由JIT，JIT将其编译成本地（机器）代码，之后要执行的时候Java解释器便可直接调用，避免再次编译。

JIT compiler的作用对象是中间产物.class字节码文件中的热点代码，生成的是与本地平台适配的机器码。而字节码文件是由javac程序编译.java源代码文件得到的。

传统的编译技术是在程序运行之前进行全局编译，编译的对象是整个源代码，编译的产物就是可以直接执行的机器码。


###### HashMap，为什么使用红黑树
相比于链表，红黑树可以将插入和查询时间复杂度降到O(logN)，而链表的插入和查询都需要遍历整个链表，复杂度均为O(N)，当数据量极大时，效率将十分低下。不过在数据量较小的情况下还去维护一棵复杂的红黑树反而有点小题大做，因此在HashMap中设置了一个树化和链表化的阈值，数据个数大于前者，就将链表转换成红黑树，数据量小于后者，就简化成一条链表。
相比于二叉搜索树，红黑树可以在插入时自动调整左右子树的高度，防止左右高度相差太大导致查询效率降低。
相比于二叉平衡树，红黑树的平衡条件没这么苛刻，插入时所做的调整没这么频繁，效率更高，但是也不会太过降低查询效率，相当于在普通二叉搜索树和平衡树之间做了一个折中。

###### synchronized
每个对象都有一个Monitor数据结构，这个数据结构中又包含了锁池和等待池这两个数据结构。synchronized关键字用来修饰一个方法或者一个代码块，表示这段代码是临界区，同一时刻只能有一个线程进入临界区执行。具体实现是利用一个对象的Monitor，只有第一个拿到Monitor的线程才能进入临界区，其他线程将被阻塞在这个对象的锁池中，直至Monitor被释放，锁池中的线程才会被唤醒来竞争这个Monitor，拿到Monitor的线程将从锁池中移除，进入临界区，其他竞争失败的线程依旧留在锁池中等待下一次被唤醒。

###### java的基本数据类型和字节数
byte:1
char:2
short:2
int:4
float:4
long:8
double:8
boolean:?
>boolean可以用1bit来存储，但是没有明确规定其大小，JVM在编译时会将boolean型数据转换成int型，boolean数组则是当做byte数组处理。

###### Java，volatile关键字
volatile是指令关键字，用于修饰指令，主要有以下两大特性：
1. 可见性：保证每个线程都能看到最新的共享变量值。大致的实现方式如下：
假设有多个线程已经加载了共享变量val的副本到各自的工作内存中，此时线程A对val的值进行了更新并写入主内存，那么其他线程的工作内存中加载的val副本就会失效。当其他线程要用到val时，会发现工作内存中存放val副本的地址已经失效，就会重新去主内存中加载val的值进来。
2. 有序性：通过内存屏障（也叫栅栏）来防止编译器优化volatile声明的指令进行顺序重排。

###### ReentrantLock
* 重入锁，顾名思义，就是已经拿到锁的线程可以重复拿锁。
* ReentrantLock分为公平锁和非公平锁。
* 它们的区别在于当有新的线程想要拿锁的时候，公平锁只会让第一个线程去做拿锁的尝试，而后面的线程只能进入队列中等待；但是非公平锁会让每一个新来的线程都去进行拿锁的尝试，一旦锁刚好被释放，就有一定概率比队头的线程先拿到锁，就不用再排队，违反先来后到的公平机制，故是非公平的锁。

###### JMM
Java内存模型：将内存条划分为主内存和多个工作内存，每个线程都拥有一个工作内存。主内存用于存放共享变量，工作内存存放共享变量副本，线程不能直接操作主内存中的共享变量，需要将主存中的共享变量加载到工作内存才能够操作。
>不能与JVM内存分区混为一谈。JVM内存分区是物理上的划分，而JMM是逻辑上的划分。
