###### 进程如何同步
1. 信号量  
信号量本质就是一个整型变量，通过P和V操作来控制同步进程对临界区的访问。所谓临界区，就是一段对临界资源进行访问的代码。  
P、V操作都是原子性的操作，通过在运行期间屏蔽中断的方式来实现原子性。P将信号量s的值减一，V则将s加一。s的初始值表示能同时进入临界区的进程数目。如果s为非正数，P操作将其减一后会将调用P方法的进程加入阻塞队列。V则从阻塞队列中释放出一个进程。

2. 管程  
一般用于解决生产者消费者问题，相比信号量，省去了很多控制代码。管程的特点是只能有一个进程进入管程，其他进程都将被阻塞。管程通过使用2个条件变量full和empty的wait()和signal()操作来控制生产者和消费者的行为，避免向满缓冲区中插入东西或者消费空缓冲区。

3. 消息队列  
消息队列实际上是以一对原语来实现其功能，分别是send和receive，指明接收方和发送方以及要传递的消息。这样当一个进程执行完一段互斥代码后就可以调用send操作通知指定的被receive阻塞的进程去执行这段代码。

###### 进程间通信有哪些方法？
1. pipe：匿名管道，只能用于父进程与子进程之间的半双工通信。
2. FIFO：命名管道，可用于同一主机内任意两个进程间的通信，常用于客户-服务端应用程序中，FIFO作为汇聚点，在客户端进程和服务端进程之间传递数据。FIFO同步管道由读写进程创建，通过fd来访问同一个管道，从而实现进程间通信。这个管道随着读写进程的关闭而销毁。
3. 消息队列：不同于FIFO，消息队列进程独立于读写进程。
>~~（面试不用说）消息队列具有以下优点：
(1)消息队列独立于读写进程，由消息队列这个进程来负责统一管理，避免了FIFO的同步打开与关闭困难（如多进程打开文件时的重名问题，此时其他同步进程将出现报文件打开失败的错误）。
(2)读写进程仅需调用消息队列的API进行读写操作，不用自己提供同步方法，避免了FIFO的同步阻塞问题。
(3)消息队列中可以存放很多个打开的fd，读进程可以根据需要读取特定类型的消息。但是FIFO只能存放一个fd，读进程一股脑的读一堆进来，然后再将不需要的舍弃。~~
4. 信号量：就是一个计数器，用于同步多个进程对共享数据对象的访问。
5. 共享存储：多个进程共享同一块内存。具体来说是将这块内存映射到进程内的地址空间中，不用在内核空间中创建该存储块的fd，直接通过用户空间中的逻辑地址就能访问到同一个存储块的物理空间。这种方式需要使用信号量来同步对共享存储的访问，仅适用于要共享大块数据时。
6. Socket：用于跨主机或跨LAN的进程间通信。

>参考资料：
* [目前linux进程间通信的常用方法是什么(pipe？信号量？消息队列？)?](https://www.zhihu.com/question/23995948)
* [进程间通信-管道](https://zhuanlan.zhihu.com/p/106222551)
* [semaphore和mutex的区别？](https://www.zhihu.com/question/47704079)

###### 文件IO
每个文件file都有一个文件描述符fd，fd这个对象主要是用来指向文件所在地址。
当执行read操作时，会产生系统调用，内核会通过fd，从磁盘上文件的对应位置，以扇区(block)为单位，即4KB为单位加载进内核空间的页框（也是4KB）中，再从内核空间读取到用户空间的页框中，即完成一次读取（载入）操作。
当执行write操作时，也会产生一个系统调用，将指定的用户空间的n个内存页的内容写入内核空间的缓冲区，再写入磁盘的n个扇区。

###### 进程和线程，区别，哪个效率高，为什么
1. 定义：进程是资源分配的基本单位。线程是处理器调度的基本单位。
2. 区别：一个进程可拥有多个线程。每个进程都拥有自己独立的地址空间，而同一个进程内的线程共享该进程的地址空间。
3. 效率高低比较：
多进程并发与多线程并发没有绝对的效率高低，要视情况而定。  
如果是不同进程的线程切换，则与进程切换无异。  
如果是同一进程内的线程切换，则其成本和效率比进程切换效率更高。进程切换时，需要MMU进行缓存的刷新，即先清除前一个进程的缓存再加载后一个进程的缓存。但是进程内的线程切换无需进行如此大规模的MMU缓存刷新操作，开销较小。

###### 死锁的条件，如何解决
死锁是多个并发进程因争夺系统资源而产生相互等待的状态。  
死锁有4个必要条件：
1. 互斥：不能有2个以上的进程同时占有同一份资源。
2. 占有且等待：一个进程在等待另一个进程释放其所需的资源。
3. 不可抢占：一个进程不可强行将另一个进程已经占有的资源抢过来。
4. 循环等待：存在一个进程链，每个进程所需的部分资源被后一个进程所占有。

解决方案  
1. 死锁预防：破坏4个必要条件之一。比如破坏“占有且等待”，就可以在进程开始运行前就一次性为其分配好所有需要的资源。
2. 死锁避免：在进程运行前进行判断，只允许不会产生死锁的进程申请资源。比如银行家算法，通过提前模拟一个进程的运行过程来判断是否会导致死锁。
