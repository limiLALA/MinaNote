### 2.17
###### 进程和线程，区别，哪个效率高，为什么
进程是资源分配的基本单位。线程是处理器调度的基本单位。

~~一个程序至少有一个进程~~，一个进程至少有一个线程。
每个进程都拥有自己独立的地址空间，但是同一个进程中的线程则共享进程的同一块内存区域。

多线程的效率比多进程更高，因为线程的切换开销更小，进程的切换需系统切换到内核态。用户级线程的切换无需切换到内核态，其工作对内核不可见。（这段不够严谨。1.线程的切换要具体到进程内线程的切换和不同进程的线程的切换。2.进程的切换得和mmu的缓存刷新结合起来说。3.用户级线程可以不用说，一般我们把用户级线程叫做协程。）

###### 事务的特性，具体介绍
ACID
原子性：事务中的~~工作~~步骤要么不做，要么全做。

一致性：事务执行的结果应该是使数据库从一种一致性状态变为另一种一致性状态。即哪怕事务被意外中断，其所做的修改不会更新到物理数据库上，即为一致性。（这里可以举一个转账的例子）

隔离性：并发执行多个事务，互不干扰

持续性：事务一旦提交，其对数据库的改变就是永久性的。

###### 隔离级别，具体介绍
读未提交：所有事务可以看到其他未提交事务的执行结果。读未提交的数据，称为脏读。
读提交：所有事务只可以看到其他已提交事务的执行结果。
可重复读：在一次事务执行期间读到的数据都是一致的。
串行化：后来的事务必须等待前一个事务执行完毕才能开始执行。

###### 幻读（不够严谨，建议先看看mysql专栏）
在不同时刻读到不同的数据的现象，就是幻读。
在MySQL中，通过将库的引擎设置为支持事务的引擎，如InnoDB，使用可重复读的隔离级别即可解决幻读问题。可重复读是通过在事务开始执行时生成一份一致性视图，即静态视图来实现的，在事务执行期间一直使用这份视图进行读操作，这样无论在什么时刻读都不会读到前后不一致的值。

###### 死锁的条件，如何解决
死锁是多个并发进程因争夺系统资源而产生的相互等待的状态。
死锁有4个必要条件：
1. 互斥：不能有2个以上的进程同时占有同一份资源
2. 占有且等待：一个进程在等待另一个进程释放自己所需的资源
3. 不可抢占：一个进程不能将另一个进程已经占有的资源强行抢过来。
4. 循环等待：存在一个进程链，或者说环，这个环中，每个进程都在等待前一个进程释放资源。

解决方案  
1. 死锁预防：破坏4个必要条件之一。比如破坏“占有且等待”，就可以在进程运行之前就将其需要的全部资源都一次性分配给它。
2. 死锁避免：在进程运行前进行判断，拒绝会引发死锁的进程的资源请求。比如银行家算法，就是通过事先模拟一个进程的运行过程，从而判定是否会引发死锁。
