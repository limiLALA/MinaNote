### 2.22
###### 进程如何同步

###### 进程间通信有哪些方法？
1. pipe：匿名管道，只能用于父进程与子进程之间的半双工通信。
2. FIFO：命名管道，可用于同一主机内任意两个进程间的通信，常用于客户-服务端应用程序中，FIFO作为汇聚点，在客户端进程和服务端进程之间传递数据。FIFO同步管道由读写进程创建，通过fd来访问同一个管道，从而实现进程间通信。这个管道随着读写进程的关闭而销毁。
3. 消息队列：不同于FIFO，消息队列具有以下优点：
(1)消息队列独立于读写进程，由消息队列这个进程来负责统一管理，避免了FIFO的同步打开与关闭困难（如多进程打开文件时的重名问题，此时其他同步进程将出现报文件打开失败的错误）。
(2)读写进程仅需调用消息队列的API进行读写操作，不用自己提供同步方法，避免了FIFO的同步阻塞问题。
(3)消息队列中可以存放很多个打开的fd，读进程可以根据需要读取特定类型的消息。但是FIFO只能存放一个fd，读进程一股脑的读一堆进来，然后再将不需要的舍弃。
4. 信号量：就是一个计数器，用于同步多个进程对共享数据对象的访问。
5. 共享存储：多个进程共享同一块内存。具体来说是将这块内存映射到进程内的地址空间中，不用在内核空间中创建该存储块的fd，直接通过用户空间中的逻辑地址就能访问到同一个存储块的物理空间。这种方式需要使用信号量来同步对共享存储的访问，仅适用于要共享大块数据时。
6. Socket：用于跨主机或跨LAN的进程间通信。

[目前linux进程间通信的常用方法是什么(pipe？信号量？消息队列？)?](https://www.zhihu.com/question/23995948)
[进程间通信-管道](https://zhuanlan.zhihu.com/p/106222551)
[semaphore和mutex的区别？](https://www.zhihu.com/question/47704079)

### 2.21
###### 谈谈你对线程池的理解
线程池的思想有点类似于IoC，也是控制反转。将手动创建线程变成了由机器自动创建线程，根据系统情况调整线程数目，降低了内存的消耗，并减少了创建和销毁线程的次数，每个工作线程可被重复利用。

###### 浏览器输入完url按下回车开始到返回页面的过程
假设使用的是HTTP协议。
1. 浏览器先查询本地host，如果没有匹配的URL，就向DNS服务器发送查询请求，本地域名服务器向根域名服务器查询一般使用迭代查询。浏览器收到正常回复后即拿到对应的IP地址。
2. 浏览器生成一个HTTP请求报文，交由OS的传输层，将这份HTTP请求拆分成字节流，套上TCP头，交给网络层。
3. 网络层对收到的TCP数据流进行分组，生成IP包，交给链路层。
4. 如果IP属于外网，会将MAC地址设置成路由器的MAC；如果是内网IP，就查询本地ARP缓存，如果没有记录，就向路由器发送ARP请求，取得对应机器的MAC地址。这里假设IP属于外网。
5. 链路层给IP包套上MAC头，然后将生成的MAC帧交给物理层。
6. OS将完整的帧发送出去，路由器收到后，根据IP层的目标IP地址，加上下一跳的MAC地址，进行相应的转发。
7. 经过若干次转发后，到达目标局域网的路由器（即最后一跳）。路由器取下IP头，发现这个包是发给自己管辖的局域网内的主机，没有下一跳了，于是进行ARP，获得目标主机的MAC地址后，发送到自己的局域网下。
8. 目标主机收到了这个包，接收过程是发送过程的逆过程，最终这个HTTP请求报文会被交给监听对应端口的进程去处理。
9. 进程处理好后，会生成一个HTTP响应报文，经过同样的过程，层层封装好后发给我们的浏览器。
10. 浏览器收到HTTP响应报文后，取出其中的html内容，然后就可以展示这个完整的网页了。
[Linux系统下搭建DNS服务器——DNS原理总结](https://zhuanlan.zhihu.com/p/31568450)

### 2.20
###### 什么叫做JIT compiling，与传统的编译技术有何不同。
JIT，Just-In-Time，是即时的意思，即时编译器也叫做热点编译器，是一种动态编译器。

不同于C/C++的静态编译，JIT compiler是运行时编译（Runtime Compilation），一般应用于Java虚拟机中。Java解释器会将热点代码（即频繁被执行的字节码）交由JIT，JIT将其编译成本地（机器）代码，之后要执行的时候Java解释器便可直接调用，避免再次编译。

JIT compiler的作用对象是中间产物.class字节码文件中的热点代码，生成的是与本地平台适配的机器码。而字节码文件是由javac程序编译.java源代码文件得到的。

传统的编译技术是在程序运行之前进行全局编译，编译的对象是整个源代码，编译的产物就是可以直接执行的机器码。

###### HashMap，为什么使用红黑树
相比于链表，红黑树可以将插入和查询时间复杂度降到O(logN)，而链表的插入和查询都需要遍历整个链表，复杂度均为O(N)，当数据量极大时，效率将十分低下。不过在数据量较小的情况下还去维护一棵复杂的红黑树反而有点小题大做，因此在HashMap中设置了一个树化和链表化的阈值，数据个数大于前者，就将链表转换成红黑树，数据量小于后者，就简化成一条链表。
相比于二叉搜索树，红黑树可以在插入时自动调整左右子树的高度，防止左右高度相差太大导致查询效率降低。
相比于二叉平衡树，红黑树的平衡条件没这么苛刻，插入时所做的调整没这么频繁，效率更高，但是也不会太过降低查询效率，相当于在普通二叉搜索树和平衡树之间做了一个折中。

###### synchronized
每个对象都有一个Monitor数据结构，这个数据结构中又包含了锁池和等待池这两个数据结构。synchronized关键字用来修饰一个方法或者一个代码块，表示这段代码是临界区，同一时刻只能有一个线程进入临界区执行。具体实现是利用一个对象的Monitor，只有第一个拿到Monitor的线程才能进入临界区，其他线程将被阻塞在这个对象的锁池中，直至Monitor被释放，锁池中的线程才会被唤醒来竞争这个Monitor，拿到Monitor的线程将从锁池中移除，进入临界区，其他竞争失败的线程依旧留在锁池中等待下一次被唤醒。

### 2.19
###### java的基本数据类型和字节数
byte:1
char:2
short:2
int:4
float:4
long:8
double:8
boolean:?
>boolean可以用1bit来存储，但是没有明确规定其大小，JVM在编译时会将boolean型数据转换成int型，boolean数组则是当做byte数组处理。

###### Java，volatile关键字
volatile是指令关键字，用于修饰指令，主要有以下两大特性：
1. 可见性：保证每个线程都能看到最新的共享变量值。大致的实现方式如下：
假设有多个线程已经加载了共享变量val的副本到各自的工作内存中，此时线程A对val的值进行了更新并写入主内存，那么其他线程的工作内存中加载的val副本就会失效。当其他线程要用到val时，会发现工作内存中存放val副本的地址已经失效，就会重新去主内存中加载val的值进来。
2. 有序性：通过内存屏障（也叫栅栏）来防止编译器优化volatile声明的指令进行顺序重排。

###### mysql索引结构，特点，为什么使用这个
索引可以使用二叉搜索树、哈希表、B-树、B+树来实现。
1. MySQL采用B+树作为索引结构。
2. B+树的特点是树高比二叉搜索树低，这样查询数据时需要访问的层数可大大减少。
3. 原因：
* 与二叉搜索树相比，由于B+树是n叉搜索树，在同样数据量的情况下，B+树的高度不会过高。一般而言，索引的一个结点中的所有数据会存放在同一个扇区内，因此对索引每一层的访问都对应一次磁盘I/O，其时间主要分为2块，磁头移动寻找磁道的时间和磁盘转动寻找扇区的时间。故磁盘I/O的时间比内存I/O要长很多。因此减少磁盘访问次数就成为了提高数据库查询效率的关键点。
* 与哈希表相比，B+树支持范围查询，而哈希表不支持。
* 与B-树相比，B+树的非叶子节点不存储真实数据，而只会存放辅助查找的值，而B-树的真实数据分布在不同的层上，要进行范围遍历时会比较麻烦。B+树只要直接将所有叶子节点用双向链表进行组织，就可进行范围查询，非常方便。

>* 二叉平衡树：左右子树的最大深度之差不能超过1
* 红黑树：本质也是一棵二叉搜索树，规则是左右子树中更深的那棵子树的长度不能大于另一棵的两倍

###### ReentrantLock
* 重入锁，顾名思义，就是已经拿到锁的线程可以重复拿锁。
* ReentrantLock分为公平锁和非公平锁。
* 它们的区别在于当有新的线程想要拿锁的时候，公平锁只会让第一个线程去做拿锁的尝试，而后面的线程只能进入队列中等待；但是非公平锁会让每一个新来的线程都去进行拿锁的尝试，一旦锁刚好被释放，就有一定概率比队头的线程先拿到锁，就不用再排队，违反先来后到的公平机制，故是非公平的锁。

###### JMM
Java内存模型：将内存条划分为主内存和多个工作内存，每个线程都拥有一个工作内存。主内存用于存放共享变量，工作内存存放共享变量副本，线程不能直接操作主内存中的共享变量，需要将主存中的共享变量加载到工作内存才能够操作。
>不能与JVM内存分区混为一谈。JVM内存分区是物理上的划分，而JMM是逻辑上的划分。

### 2.18
###### 文件IO
每个文件file都有一个文件描述符fd，fd这个对象主要是用来指向文件所在地址。
当执行read操作时，会产生系统调用，内核会通过fd，从磁盘上文件的对应位置，以扇区(block)为单位，即4KB为单位加载进内核空间的页框（也是4KB）中，再从内核空间读取到用户空间的页框中，即完成一次读取（载入）操作。
当执行write操作时，也会产生一个系统调用，将指定的用户空间的n个内存页的内容写入内核空间的缓冲区，再写入磁盘的n个扇区。

### 2.17
###### 进程和线程，区别，哪个效率高，为什么
1. 定义：进程是资源分配的基本单位。线程是处理器调度的基本单位。
2. 区别：一个进程可拥有多个线程。每个进程都拥有自己独立的地址空间，而同一个进程内的线程共享该进程的地址空间。
3. 效率高低比较：
多进程并发与多线程并发没有绝对的效率高低，要视情况而定。  
如果是不同进程的线程切换，则与进程切换无异。  
如果是同一进程内的线程切换，则其成本和效率比进程切换效率更高。进程切换时，需要MMU进行缓存的刷新，即先清除前一个进程的缓存再加载后一个进程的缓存。但是进程内的线程切换无需进行如此大规模的MMU缓存刷新操作，开销较小。

###### 事务的特性，具体介绍
ACID
* 原子性：事务中的步骤要么不做，要么全做。
* 一致性：(选其一回答)
>抽象解释：事务执行的结果应该是使数据库从一种一致性状态变为另一种一致性状态。即哪怕事务被意外中断，其所做的修改不会更新到物理数据库上，即为一致性。
>举例解释：举个转账的例子，A转账给B一百块钱，要执行两步操作，首先从A的账户余额中扣除100，然后给B的账户余额增加100。这个转账操作必须是一个原子性的操作，否则，如果执行了第一步余额扣除操作，并同步到物理数据库上，此时事务突然被意外中断，第二步操作没有执行，那么A和B的总资产就变少了，此时就不是一致性状态了。

* 隔离性：并发执行多个事务，互不干扰。
* 持续性：事务一旦提交，其对数据库的改变就是永久性的。

###### 隔离级别，具体介绍
读未提交：所有事务可以看到其他未提交事务的执行结果。读未提交的数据，称为脏读。
读提交：所有事务只可以看到其他已提交事务的执行结果。
可重复读：在一次事务执行期间读到的数据都是一致的。
串行化：后来的事务必须等待前一个事务执行完毕才能开始执行。

###### 幻读
在不同时刻读到不同的数据的现象，就是幻读。
在MySQL中，通过将库的引擎设置为支持事务的引擎，如InnoDB，使用可重复读的隔离级别即可解决幻读问题。可重复读是通过在事务开始执行时生成一份一致性视图，即静态视图来实现的，在事务执行期间一直使用这份视图进行读操作，这样无论在什么时刻读都不会读到前后不一致的值。

###### 死锁的条件，如何解决
死锁是多个并发进程因争夺系统资源而产生相互等待的状态。  
死锁有4个必要条件：
1. 互斥：不能有2个以上的进程同时占有同一份资源。
2. 占有且等待：一个进程在等待另一个进程释放其所需的资源。
3. 不可抢占：一个进程不可强行将另一个进程已经占有的资源抢过来。
4. 循环等待：存在一个进程链，每个进程所需的部分资源被后一个进程所占有。

解决方案  
1. 死锁预防：破坏4个必要条件之一。比如破坏“占有且等待”，就可以在进程开始运行前就一次性为其分配好所有需要的资源。
2. 死锁避免：在进程运行前进行判断，只允许不会产生死锁的进程申请资源。比如银行家算法，通过提前模拟一个进程的运行过程来判断是否会导致死锁。
