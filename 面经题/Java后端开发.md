### 2.17
* 进程和线程，区别，哪个效率高，为什么
进程是资源分配的基本单位。线程是处理器调度的基本单位。

一个程序至少有一个进程，一个进程至少有一个线程。
每个进程都拥有自己独立的地址空间，但是同一个进程中的线程则共享进程的同一块内存区域。

多线程的效率比多进程更高，因为线程的切换开销更小，进程的切换需系统切换到内核态。用户级线程的切换无需切换到内核态，其工作对内核不可见。

* 事务的特性，具体介绍
ACID
原子性：事务中的工作要么不做，要么全做。
一致性：事务执行的结果应该是使数据库从一种一致性状态变为另一种一致性状态。即哪怕事务被意外中断，其所做的修改不会更新到物理数据库上，即为一致性。
隔离性：并发执行多个事务，互不干扰
持续性：事务一旦提交，其对数据库的改变就是永久性的。

* 隔离级别，具体介绍
读未提交：所有事务可以看到其他未提交事务的执行结果。读未提交的数据，称为脏读。
读提交：所有事务只可以看到其他已提交事务的执行结果。
可重复读：在一次事务执行期间读到的数据都是一致的。
串行化：后来的事务必须等待前一个事务执行完毕才能开始执行。

* 幻读
在不同时刻读到不同的数据的现象，就是幻读。
在MySQL中，通过将库的引擎设置为支持事务的引擎，如InnoDB，使用可重复读的隔离级别即可解决幻读问题。可重复读是通过在事务开始执行时生成一份一致性视图，即静态视图来实现的，在事务执行期间一直使用这份视图进行读操作，这样无论在什么时刻读都不会读到前后不一致的值。

* 死锁的条件，如何解决
死锁是多个并发进程因争夺系统资源而产生相互等待的状态。
死锁有4个必要条件：
1. 互斥：不能有2个以上的进程同时占有同一份资源。
2. 占有且等待：一个进程在等待另一个进程释放其所需的资源。
3. 不可抢占：一个进程不可强行将另一个进程已经占有的资源抢过来。
4. 循环等待：存在一个进程链，每个进程所需的部分资源被后一个进程所占有。
解决方案
1. 死锁预防：破坏4个必要条件之一。比如破坏“占有且等待”，就可以在进程开始运行前就一次性为其分配好所有需要的资源。
2. 死锁避免：在进程运行前进行判断，只允许不会产生死锁的进程申请资源。比如银行家算法，通过提前模拟一个进程的运行过程来判断是否会导致死锁。
