## HashMap的底层实现
```Java
HashMap<String, String> map =  new HashMap<String, String>();
map.put( "张三"， "测试数据" );
map.put( "李四"， "测试数据" );
```

JDK 1.8中的HashMap是底层实现就是一个数组。上述代码最终存储形式大致如下所示：
```Java
[<>,<>,<>,<>,<"张三","测试数据">,<"李四","测试数据">,<>,<>,<>,<>,<>,<>]
```
这里假设数组长度为16。

## HashMap的查找
在进行如下查找时，会先计算"张三"的HashCode，然后对哈希值进行某种优化，再对数组长度取模，即得到对应数据的索引。比如这里的索引是4，于是get这个函数会返回array[4]。
```Java
map.get("张三")
```

## 哈希算法的优化
```Java
// 源码
static final int hash(Object key){
  int h;
  return (key==null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
key.hashCode()获得一个"张三"的初步的哈希值，紧接着将这个初始哈希值与右移16位的初始哈希值进行异或运算。

这里实际上是将初始哈希值的高16位与低16位进行异或运算，这样优化的原因如下：  
假设有2个不同的key，他们的初始哈希值的低16位完全相同，高16位不同，如果直接与数组长度16进行取余运算，那计算结果将一样，此时发生哈希碰撞。   
使用优化后的哈希值对16取余，那结果一般都不相同，此时便可减少哈希冲突。

## 寻址算法的优化
>位运算的效率高于算术运算的效率

上面我们说对16取余的操作就是寻址操作，如果我们不对16取余，而是改为与(16-1)进行与运算，效率会大大提高，并且结果是等价的。

这样优化的前提是数组长度n为2的幂次方。

*(n - 1) & hash*

## 哈希碰撞的处理
**链表+红黑树 O(n) O(logn)**

假设在array[4]处发生哈希冲突，则在array[4]处存储的就是一条链表的表头，链表上挂着发生哈希冲突的键值对。

当链表的长度大于某个值时，就会转换成红黑树，查找效率为O(logn)。

## 哈希表的扩容
**翻倍扩容**

假设原来的数组长度为16，触发扩容条件时，会将容量扩充至32，此时要进行rehash。

rehash的过程：对每一个哈希值，和(32-1)进行与运算,如果结果和原来不同，说明要搬家，新家的索引值就是(原来的索引值+16)。
