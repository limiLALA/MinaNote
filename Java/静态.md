在静态域（静态方法，静态属性，静态代码块中），静态方法永远是最后执行的，跟顺序无关，而其他两个跟声明的顺序有关

# 抽象、静态、最终
1. 抽象方法只能定义在抽象类中，抽象方法和抽象类必须由abstract修饰，abstract关键字只能描述类和方法，不能描述变量。

抽象方法只定义方法声明，不定义方法实现。抽象类不可以被实例化（创建对象），只有通过子类继承抽象类并覆盖抽象类中的所有抽象方法后，该子类才可以被实例化，否则该子类还是一个抽象类。

抽象方法只可以被public 和 protected修饰；

抽象类中有构造函数用于给子类对象进行初始化，同时抽象类中可以含有非抽象方法。

abstract关键字不可以与final，private,static关键字共存，因为被final修饰的方法不可以被重写，意味着子类不可以重写该方法。

如果abstract和final共同修饰父类中的方法，子类要实现抽象方法（abstract的作用），而final又不让该方法重写，这相互矛盾。

如果private和abstract共同修饰父类中的方法，private修饰则该方法不可以被子类访问，但是abstract修饰需要子类去实现，两者产生矛盾。

如果static和abstract共同修饰父类中的方法，static表示是静态的方法，随着类的加载而加载，则该方法不需要在子类中去实现，这与abstract关键字的多态动态的特性矛盾。

2. static用于修饰成员变量和成员函数，想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰，被静态修饰的成员可以直接被类名调用，静态随着类的加载而加载，而且优先于对象存在。

static是一个类独有的，即使子类中定义了同名的static方法(即重写)，通过父类的接口调用的仍然是父类的静态方法。

静态方法只能访问静态成员（静态方法和静态变量），不可以访问非静态成员，这是因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。

静态方法中不能使用this和super关键字，因为this代表本类对象，super代表父类对象，而静态时，有可能没有对象存在，所以this和super无法使用。

3. final关键字可以修饰类，方法，变量（成员变量内，局部变量，静态变量），被final修饰的类是一个最终类，不可以被继承，被final修饰的方法是一个最终方法，不可以被覆盖，但是可以被继承。

final可以修饰类、方法、变量，分别表示：该类不可继承、该方法不能重写、该变量是常量

内部类被定义在类中的局部位置上时，只能访问局部被final修饰的局部变量。？？？？？
