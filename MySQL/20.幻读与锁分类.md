# 幻读
### 什么是幻读
幻读简单来说就是一个事务在前后两次相同范围的查询操作中，后一次查询看到了前一次查询没有看到的行。
>如果前后两次查询到的是同一行，只是行中的具体数据不一致，不叫幻读。只有其他线程插入的新行才叫幻读。

### 幻读造成的问题
1. 语义上的问题
2. 数据一致性问题：数据和日志在逻辑上的一致。

### 举例说明
在MySQL中，幻读一般是读提交隔离级别下的一个问题。举个例子，有一个表T，其中有3个整型字段(id,a,b)，id为主键，a为索引。建表语句和初始数据如下：
```sql
create table t(
  id int PRIMARY KEY,
  a int NOT NULL,
  b int NOT NULL,
  index a(a)) ENGINE=InnoDB;
insert into t values(0,0,0),(5,5,5),(7,7,7),(10,10,10);
```
三事务并发运行过程如下：
1. T1时刻：Session A
```sql
select * from t where b = 5;
```
2. T2时刻：Session b
```sql
update t set b = 5 where id = 0;
```
3. T3时刻：Session A
```sql
select * from t where b = 5;
```
4. T4时刻：Session C
```sql
insert into t values(3,3,5);
```
5. T5时刻：Session A
```sql
select * from t where b = 5;
```
T1时刻，结果是(5,5,5)；
T3时刻，结果是(0,0,5),(5,5,5)；  
T5时刻，结果是(0,0,5),(3,3,5),(5,5,5)；  
可以看到，事务A执行期间不同时刻执行同一个Select语句得到的结果不一致。不过只有T3到T5才算是幻读，因为插入了一条新行。

------------------------------------------------
# 常用的锁
>锁仅在事务回滚或者程序中断或者commit时才会被释放。

### 按作用范围划分
**表锁(Table lock)**：随整个表对象进行加锁。

**行锁(Record lock)**：对某个记录进行加锁。

**间隙锁(Gap lock)**：开区间。对两行记录中间的间隙进行加锁，与在该区间内进行的插入操作互斥。
>* 间隙锁的**动态范围调整**：间隙锁只会锁住两行记录中间的间隙，但不会锁住边界上的两条记录。如果另一个线程将边界记录删除了，此时间隙锁的范围将动态扩大到最邻近的边界，同样还是开区间。
>* 间隙锁的**权限控制问题**：间隙锁类似于读锁，仅限制其他线程对此开区间的写操作（这里只有插入操作），由于间隙锁的开区间中无数据，故其他线程对此区间进行读操作时不会被阻塞，会直接返回空集。
>* 间隙锁的**死锁问题**：根据上一点的说明，同一个开区间可以有多个线程利用select ... for update语句对其加上间隙锁，加上多个间隙锁后，如果这些线程都要对这个开区间进行插入操作，然后每个线程都在等待其他线程释放掉间隙锁，就会造成死锁。

**间隙锁-行锁(Next-key lock)**：所有区间均为左开右闭。
>间隙锁-行锁的左边界是开，故也有动态范围调整。只要另一个线程将未锁住的左边界删除即可扩大锁的范围。

### 按功能划分
#### for update
for update 称为排它锁/独占锁。

InnoBD会对insert/delete/update语句进行自动加锁，但是不会对select语句加锁，因此需要手动加锁。

select ... for update是常用的手工加锁的语句。
* 如果查找条件基于id主键或者索引a，则只会锁住id对应的行，即给这一行的记录对象加上行锁。
* 如果查找条件基于普通字段，则需要按照主键顺序遍历整张表，此时会锁住整个表，即给表对象加上表锁。
* 如果查找条件基于一个不存在的索引值，则会加上某个范围的Gap lock，这个范围的边界是离索引值最近的两个端点。
* 如果查找条件基于一个左开右闭范围的索引值，则会加上对应范围的Next-key lock。

#### lock in share mode
lock in share mode 称为共享锁，是当前读，只有第一个拿到共享锁的线程才可以对指定范围内的数据进行读写操作，其他后面拿到共享锁的线程只能进行读操作。
