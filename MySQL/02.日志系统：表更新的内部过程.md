# 表的更新
表T的创建与更新语句如下：
```sql
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;
```
ID为主键，其中有一个整型数据c。
更新语句将ID=2这一行的c自增1.

更新流程与查询流程类似，连接器先连接服务器，分析器检查词法、解析语法，知道这是一条更新语句，优化器对其进行优化处理后告诉执行器怎么做，执行器开始执行更新。

在执行完更新语句后，与表T相关的查询缓存都会失效。

与查询流程不同的是，执行器在更新过程中会涉及到2个重要的日志模块：redo log和binlog。

##### redo log与binlog的区别
1. redo log是InnoBD引擎特有的，而binlog在Server层实现，所有引擎均可使用。
2. redo log是物理日志，记录的是在“某个数据页上做了什么修改”；binlog是逻辑日志，记录的是语句的是语句的原始逻辑，比如“给ID=2这一行的c字段加1”。
3. redo log是循环写入的，空间大小固定；binlog是追加写入，写一个文件写完了会去下一个文件中写，不会覆盖旧日志。

##### redo log与binlog的作用
* redo log起到一个长期缓存的作用，提高数据库更新效率。
* binlog起到备份的作用，防止数据丢失，保证数据库能够恢复到过去一段时间的任何一秒钟的状态。

--------------------------------------------------
### 重做日志：redo log
当有一条记录需要更新时，InnoDB会先将更新写在redo log中，并更新内存，等到适当的时候或空闲时再写入磁盘。

redo log固定大小，如果配置为一组4个文件，每个文件1G，就可记录4G操作。写到末尾后再回到开头循环写。

**write pos**：指向当前要记录的位置，一边记录一边往后移。

**checkpoint**：指向要擦除的位置，在记录更新到磁盘后再擦除，然后往后移。

如果write pos追上了checkpoint，说明不能再写入更新操作，必须等待擦除完旧的记录、checkpoint往后移动后，才能再往redo log中写入新的更新记录。

##### crash safe
有了redo log，InnoDB数据库即使发生异常重启，之前提交的记录都不会丢失，这种能力就是crash safe。

--------------------------------------------------
### 归档日志：binlog
在Server层记录更新语句的原始逻辑。“归档”，顾名思义，就是记录历史，所以是追加写入。没有crash safe功能。

--------------------------------------------------
## 执行器与InnoDB引擎执行更新语句的内部流程
1. 执行器找引擎取ID=2这一行数据。
2. 引擎先看看内存中有没有加载，如果没有，就去磁盘中将这一行数据加载到内存中，返回给执行器。
3. 执行器取出c字段的数据，进行加1的运算，形成一行新的数据。
4. 执行器将新的这一行数据交给引擎。
5. 引擎将数据更新到内存中。
6. 引擎将记录写入redo log，此时redo log处于prepare状态。
7. 引擎告诉执行器已经更新好了，随时可以提交事务。
8. 执行器写下这条更新记录的binlog，并将该binlog写入磁盘。
9. 执行器调用引擎的提交事务接口。
10. 引擎将刚写入的redo log改成为提交(commit)状态。更新完成。

#### 两阶段提交
redo log和binlog都可以用来表示事物的提交状态，两阶段提交就是让两个状态保持逻辑上的一致性。
