# 概述
* ### 开销大，加锁慢
* ### 会出现死锁
* ### 粒度小
> 发生锁冲突的概率低，并发度高


# 原理
## 行锁的实现机制由row trx_id 和 tx_id 组成
> 首先每一行数据的操作，都有一个对应的版本号，记录了这个视图的id
这里以 可重复读 级别的事务来举例说明
每一个事务在创建的时候，都会生成一个一致性视图，在事务之前提交的数据会在该视图中，可读。而未提交的事务，则不会在这个视图中。
当前事务对于行有两种读法，一种是DQL读，一种是DML的当前读。
>> ### 对于select读而言，他只能读到两种行
一种是在自己的视图创建之前，就已经提交了的
第二种就是自己这个视图提交的。
如果当前版本不是自己提交的，那么向前寻找更早的版本，这里通过innodb的undo log实现，直到那个版本，也就是视图的id比当前小。
或者说存在于自己所记录的可见视图版本号的数组中时，说明该版本对自己的select读可见。
>> ### 对于update读而言，他做的事是当前读
当前读就要读当前的版本，不管是否是自己更新的，也不管是否是自己可见的版本。
否则update之后就会丢失其他事务做的更改，一致性被破坏。
