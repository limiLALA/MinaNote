# 表的更新
表T的创建与更新语句如下：
```sql
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;
```
ID为主键，其中有一个整型数据c。
更新语句将ID=2这一行的c自增1.

更新流程与查询流程类似，连接器先连接服务器，分析器检查词法、解析语法，知道这是一条更新语句，优化器对其进行优化处理后告诉执行器怎么做，执行器开始执行更新。

在执行完更新语句后，与表T相关的查询缓存都会失效。

与查询流程不同的是，执行器在更新过程中会涉及到2个重要的日志模块：redo log和binlog。

##### redo log与binlog的区别
1. redo log是InnoBD引擎特有的，而binlog在Server层实现，所有引擎均可使用。
2. redo log是物理日志，记录的是在“某个数据页上做了什么修改”；binlog是逻辑日志，记录的是语句的是语句的原始逻辑，比如“给ID=2这一行的c字段加1”。
3. redo log是循环写入的，空间大小固定；binlog是追加写入，写一个文件写完了会去下一个文件中写，不会覆盖旧日志。


### 重做日志：redo log
当有一条记录需要更新时，InnoDB会先将更新写在redo log中，并更新内存，等到适当的时候或空闲时再写入磁盘。

redo log固定大小，如果配置为一组4个文件，每个文件1G，就可记录4G操作。写到末尾后再回到开头循环写。

**write pos**：指向当前要记录的位置，一边记录一边往后移。

**checkpoint**：指向要擦除的位置，在记录更新到磁盘后再擦除，然后往后移。

如果write pos追上了checkpoint，说明不能再写入更新操作，必须等待擦除完旧的记录、checkpoint往后移动后，才能再往redo log中写入新的更新记录。

#### crash safe
有了redo log，InnoDB数据库即使发生异常重启，之前提交的记录都不会丢失，这种能力就是crash safe。

### 归档日志：binlog
在Server层记录更新语句的原始逻辑。“归档”，顾名思义，就是记录历史，所以是追加写入。没有crash safe功能。

## 执行器与InnoDB引擎执行更新语句的内部流程


#### 两阶段提交
redo log和binlog都可以用来表示事物的提交状态，两阶段提交就是让两个状态保持逻辑上的一致性。
