* 索引的出现是为了提高数据库的查询效率。
* 索引在存储引擎层实现。

------------------------------------------------
# 索引的常见模型
### 哈希表
以 **键值对(key-value)** 形式存储数据的结构。
> 哈希表只适用于**等值查询**（精确查询，比如查询叫李四的人），不适合**模糊查询**（比如查询所有姓李的人）。

### 有序数组
查询效率高（二分法）。但是插入数据不方便。
> 有序数组适用于**等值查询**和**范围（区间）查询**。

> 有序数组索引仅适用于**静态存储引擎**。

### 搜索树
##### 二叉搜索树
查询和更新的时间复杂度均为O(log(N))。
> 二叉搜索树的查询效率最高，但大多数数据库存储比你高不使用二叉树。因为索引不止放在内存中，还要写到磁盘上。  
二叉树树太高，访问磁盘的次数太多，每次访问磁盘数据块的时间都不短，实际查询效率会下降。

##### N叉搜索树
降低树的高度，从而降低访问磁盘的平均次数。

读写性能好，适配磁盘的访问模式。

最为典型的就是InnoDB使用的B+搜索树。

------------------------------------------------
# InnoDB的索引模型
表根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表。

InnoDB使用B+树索引模型，每一个索引对应一棵B+树。

建立一个表T，id为主键索引（聚簇索引），k为非主键索引（二级索引）
```sql
mysql> create table T(
id int primary key,
k int not null,
name varchar(16),
index (k))engine=InnoDB;
```
主键索引的叶子节点存的是整行的数据；非主键索引的叶子节点存的是主键的值。

### 基于主键索引和普通索引查询的区别
* 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
* 如果语句是 *select * from T where k=5*，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为**回表**。

即使用普通索引，需要多遍历一棵搜索树。

------------------------------------------------
# 索引维护
有序性：在插入新值时，如果数据页不够，有时需要进行**页分裂**，后续还有可能进行**页合并**，不仅影响性能，还影响数据页的利用率。

自增主键的定义
```sql
NOT NULL PRIMARY KEY AUTO_INCREMENT
```



#### 为什么使用自增主键
1. 性能上：自增主键的插入数据模式，属于递增插入。每插入一条新纪录，都是追加操作，不会挪动其他记录，也不会发生页分裂。
>使用业务逻辑的字段做主键，往往不容易保证有序插入，写数据的成本相对较高。

2. 存储空间：使得非主键索引的占用空间最小.
>如果作为主键的字段占用空间较多（比如身份证号），此时非主键索引的每个叶子节点存放的这个主键，其大小远远大于整型数据（自增主键）的4个或长整型的8个字节，此时不如用自增主键节省存储空间。

#### 不使用自增主键的场景
“尽量使用主键查询” 原则

KV场景：数据形式为key-value时
* 只有一个索引
* 该索引必须是唯一的索引

此时直接用唯一索引作为主键，可避免每次查询需要搜索2棵搜索树，提升效率。
