## C++内存分布
C++的内存分为5个区：堆、栈、代码区、全局/静态存储区、常量存储区
* **堆**：程序new/malloc出来的东西都放在堆区，动态分配，需要通过delete手动释放空间，否则只能在程序结束时由操作系统统一释放。
* **栈**：局部变量均放在栈区，函数调用也是利用栈，包括参数、返回地址、EBP等，由编译器管理栈内存的分配与释放。
* **代码区**：存放程序代码。即text段。
* **全局/静态存储区**：存放全局变量和静态变量的内存区域。在程序结束时统一释放。
* **常量存储区**：存放常量的区域，其内容不可修改。
>堆与自由存储区的区别
>* **自由存储区** 是C++通过new和delete动态分配和释放对象的**抽象概念**，在C++中new通过malloc实现，即藉由堆来实现。但是对new的实现进行某些修改后，也可用其他存储结构来实现，比如用常量存储区来实现。   
>* **堆** 是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。

## 栈与堆的区别
#### 1. 管理方式
* 栈由编译器管理，内存的分配和回收都由编译器自行完成。
* 堆由程序控制，运行到new时在堆中动态分配内存，delete时才回收内存。
#### 2. 空间大小
* 栈的空间较小，在VC6下为1M，可以手动修改。
* 堆的空间较大，32位系统下可达到4G。
#### 3. 产生碎片
* 栈的特点是先进后出，所使用的地址空间永远都是连续的，不存在碎片。
* 堆的内存是动态分配的，如果不停的new和delete，则会产生大量的内存碎片。
#### 4. 生长方向
* 栈是向下生长，即从高地址向低地址增长。
* 堆是向上生长，即从低地址向高地址增长。
#### 5. 分配方式
* 栈有静态分配和动态分配两种方式。静态分配是在编译阶段就为局部变量分配好内存空间。动态分配是程序中通过 *alloca* 实现，但是内存空间也是由编译器释放。
>Eg：变长数组。

#### 6. 分配效率
* 栈是机器系统提供的数据结构，计算机底层会存储栈的地址，提供入栈出栈的机器指令，效率较高。
* 堆是C/C++函数库提供的结构，机制复杂，如果要new一个对象，需要执行一定的算法查找是否有足够的内存空间，如果没有（可能是内存碎片太多），则会调用系统功能增加程序数据段的内存空间，这样就有机会申请到足够大小的内存并返回。效率明显低得多。

>堆相对于栈的缺陷
* 大量new/delete的使用会造成大量的内存碎片；
* 由于没有专门的系统支持，效率很低；
* 由于可能引发用户态和内核态的切换进行内存的申请，代价更加昂贵。

## C++中类的内存分配
#### 虚函数表
```C++
class F{
public:
  vitual void f(){
    cout<<"I'm F"<<endl;
  }
};
class S : F{
  
};
```
在上述程序中，父类F中定义了一个虚函数f()，
* 虚函数不能是静态的。
虚函数是一种特殊的成员函数，用来实现运行时多态。
静态函数可以不通过对象调用，没有隐藏的this指针。
虚函数
因为虚函数的多态特性仅存在于不同实例对象中，但是静态函数是与类绑定的，在编译时就静态绑定为class的属性，与实例无关。
